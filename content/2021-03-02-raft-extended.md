+++
template = "page.html"
date = "2021-03-02"
title = "raft-extended"
[taxonomies]
tags=["awesomepaper", "translate"]
+++

# 摘要

Raft是管理复制日志的共识算法。它产生相当于Paxos的结果，并且和Paxos效率相当，但是结果与Paxos不同，使得Raft比Paxos更容易理解，提供了对于构建实用系统更好的基础。为了加强可理解性，Raft分离了共识算法的关键要素，比如领导者选举，日志复制和安全性，并且它强调强共识以减少必须考虑的状态数量。一项用户调研显示Raft对于学生来说比Paxos更容易学习。Raft还包括了一个更改集群成员的新机制，该机制用重叠的多数来保证安全性。

## 1.介绍

共识算法允许一组计算机作为一个整体工作，这个整体允许某些成员出现故障。因此，在构建大规模可用软件系统中它扮演了重要的角色。过去的十年中，Paxos主导了共识算法的讨论，大多数共识算法的实现都是基于Paxos或者受其影响，并且Paxos已经成为了向学生传授共识算法的工具。

不幸的是，Paxos相当难理解，尽管有多种尝试使其更加适用于声场系统，但是它的结构为了支持实用系统需要复杂的变化，结果就是，系统构建者和学生都不喜欢Paxos。

在亲自与Paxos争斗之后，我们着手寻找一种新的共识算法，该算法可以为构建实用系统和学习提供更好的基础。。我们的方法目标是易于理解：我们是否能够为实用系统定义共识算法以及它是否比Paxos更容易学习？此外，我们希望该算法能够促进系统构建者的开发直觉。重要的不仅是算法可以工作，而是为什么可以工作。

工作的结论就是名为Raft的算法。在设计Raft时，我们使用各种手段提升可理解性，包括解构（Raft分离了领导者选举，日志复制和安全性），减少状态空间（相对于Paxos，Raft降低了不确定性的程度，并降低了服务器之间的不一致方式）。

Raft在许多方面与现有的共识算法类似（最著名的Oki和Liskov的Viewstamped Replication），但是它也有一些新颖的特性：

- 强领导者：Raft使用了比其他共识算法更强力的领导方式。比如，Log entries只能从领导者流向其他节点。这简化了复制日志的管理，使其更容易理解
- 领导者选举：Raft使用随机定时器来选举领导者。这相对于其他共识算法心跳加入的一点机制，可以简单快速地解决冲突
- 成员变化：Raft更改集群中服务器组的机制使用了新的联合共识的方法，其中两种不同的配置在转换过程中会重叠。这允许集群在配置更改时可以继续正常用运行

我们认为Raft在教育目的和实施基础上优于Paxos和其他共识算法。它更加简单易懂；描述了足够构建实用系统的细节，同时有了几种开源实现，并被多家公司使用。其安全性已经得到保证和证明；效率足以与其他共识算法媲美。

本文的剩余部分介绍了复制状态机问题（第二节——，讨论了Paxos的优缺点（第三节），描述了我们对于可理解性的一般方法（第四节），介绍了Raft共识算法（5-8节），Raft的评估（第九节），讨论了相关工作（第10节）

## 2. 复制状态机

共识算法通常出现在复制状态机的环境中。通过这种方法，服务器集合上的状态机可以计算相同状态的副本，即使某些服务器宕机也可以继续运行。复制状态机用来解决分布式系统中的各种容错问题。例如，具有单个集群领导者的打醒系统，比如GFS，HDFS和RAMCloud，通常使用单独的复制状态机来管理领导者选举和保存配置信息以保证领导者崩溃时的可用性。复制状态机的例子还包括Chubby和ZooKeeper

![图一](https://wendajiang.github.io/pics/raft-extended/image-20200901151351972.png)

复制状态机通常如上图使用复制日志来实现。每个服务器保存包含了一系列按序执行命令的日志。每份日志包含了同序的相同命令，所以每个状态机处理了相同的命令序列。因此状态机是确定性的，每个在相同的状态执行了相同的命令得到相同的输出。

保持复制日志一致是共识算法的工作。服务器上的共识模块接收来自客户端的命令加入到日志中。它负责与其他安装有共识模块的服务器通信保证日志以相同的顺序记录了相同的请求，即使有些服务器宕机。一旦命令被正确的复制，每个服务器的状态机以日志中的顺序处理命令，然后将输出返回客户端。结果就是，服务器表现为单个，高可用状态机。

生产系统的共识算法通常具有如下性质：

- 确保安全（不会返回一个不正确结果）在非拜占庭环境中，包括网络延迟、分区，数据包丢失、复制和重排序。
- 只要大多数服务器可以运行并且相互通信并与客户端通信，它们就可以正常运行。因此由5台服务器组成的典型集群可以容忍任何2个服务器的故障。假定服务器因停止而发生故障，它们可以稍后从稳定存储的状态机中恢复并重新加入集群
- 不依赖时间来保证日志的共识：错误的时钟和极端的消息延迟最坏情况下会导致可用性问题
- 通常情况下，只要集群的大多数服务器都响应了一次RPC，命令就可以完成，少数响应慢的服务器不影响整体系统的性能

## 3. Paxos的问题是什么

在过去的十年中，Leslie Lamport的Paxos协议几乎已经成为共识的代名词：这是课程中最常教授的协议，共识的大多数实现都是以他为起点。Paxos首先定义了一种能够在单个决定中达成一致的协议，比如单条复制日志。我们称它为"single-decree Paxos"（单判决Paxos）。Paxos接着合并多个这种协议完成一些列比如日志的决定（*multi-Paxos*）。Paxos同时保证安全性和活性，支持集群成员的改变。它的正确性已经得到了证明，并且通常情况下是高效的。

不幸的是，Paxos有两个重要缺陷。第一个是Paxos非常难以理解。[15]论文中的完整解释并不透明，很少人能成功理解它。结果就是，有数篇论文试图简单地解释Paxos。这些解释集中于*single-decree*子集，虽然这仍旧存在挑战性。在NSDI2012与会者的非正式调查中，我们发现即使是经验丰富的研究人员，也很少保持对Paxos的理解共识。我们自己也与Paxos争斗过，我们直到读了大量简单解释性的论文和设计自己的替代系统之后，这花了将近一年时间，才理解了这套协议。

我们假定Paxos的不透明性院子其single-decree子集作为基本元素的设计。Single-decree的Paxos是复杂精细的，导致整个协议分成了两个阶段，使其难以形成简单的直觉性解释而且不能单独来解释。因此，很难形成为什么single-decree协议能够工作的直观理解。multi-Paxos的组成引入了更多的复杂性和微妙性。我们相信能通过其他更为直接和简单的方式分解在多个决策阶段（比如一条日志代替一条entry）达到共识的问题。

第二个问题是Paxos不能给与构建实际系统良好的指导。原因之一是没有针对multi-Paxos的广泛的共识。Lamport的描述更多的是single-decree的Paxos，他只做了multi-Paxos实现方式的大致构想，没有太多细节。有几种具体化和优化Paxos的尝试，比如文献26,39,13，但是这些文献之间互相不同并且不同于Lamport的概述。比如Chubby这种系统实现了类Paxos算法，但是大部分细节没有公开发表。

另外，Paxos的结构不利于实现实际系统。这是single-decree分解的另一个结果。比如，单独选择一组日志条目然后融合为序列化的日志是有点好处的，这只增加了复杂性。围绕日志设计一个系统更加容易和高效，在该系统中以约束顺序添加日志条目即可。另一个问题是Paxos的核心使用对称的点对点方法（尽管它暗示了通过使用弱领导形式来优化性能）。在仅做出一个决定的问题中这是有道理的，但是几乎没有实际系统可以使用这种方法。如果需要做出一系列决策，首先选举出一个领导者更加简单快捷，随后领导者来协调决策。

结果就是，实际系统与Paxos没有什么相似之处。每种开始于Paxos的实现最终以不同的结构来呈现。这是费时而且易错的，Paxos的难以理解性加剧了这个问题。Paxos的形式化可能是证明该理论正确性的良好表达，但是实际的实现跟Paxos的证明完全不同，所以毫无实际价值。下面关于Chubby实现的论述非常经典：

> Paxos算法的描述与真实系统的需要有着巨大的差异...因此最终的系统将基于一个没有被证明的协议

由于这些问题，我们得出的结论是Paxos不能为系统构建或教育提供良好的基础。 考虑到共识在大型软件系统中的重要性，我们决定看看是否可以设计一种性能比Paxos好的替代共识算法。 Raft就是这个实验的结果。

## 4. 易理解性设计

我们设计Raft时，有几个目标：比如提供一个完整，易于构建系统的实际基础，以便减少开发人员的设计工作量；它必须在所有条件下是安全的，典型操作环境是可用的，大多数操作是高效的。但是最重要的目标是，也是最大的挑战，易于理解的。对于大多数人来说可以舒适地理解该算法。另外必须能够建立该算法的直觉，以便系统构建者可以进行实际实现中不可避免的扩展。

在Raft设计中有很多要点，我们必须在多种方法中进行选择。 在这种情况下，我们根据可理解性评估了替代方案：解释每种替代方案有多难（例如，其状态空间有多复杂，是否有微妙的暗示？），以及对读者来说有多容易完全了解该方法及其含义？

我们意识到这种分析具有相当高的主观性；不过，我们还是用了两种通用技术。第一个是众所周知的问题分解方法：无论如何，我们分解问题更小使得可以解决，解释和理解。例如，Raft中我们分开了领导者选举，日志复制，安全性和成员改变几个问题。

我们的第二个方法是通过减少需要考虑的状态简化状态空间，使系统更加协调一致，并在可能的情况下消除不确定性。尤其是，日志不允许有holes，Raft限制了导致互相之间不一致的方式。尽管大多数情况下，我们试图降低不确定性，有些场景引入不确定性可以提升可理解性。尤其是，随机方法引入了不确定性，但是通过相似的处理方法处理所有的可能性减少了状态空间（"随便选一个，无所谓"）。我们使用随机化来简化Raft领导者选举算法。

## 5. Raft共识算法

Raft是一个管理第二节描述的复制日志的算法。图2简介的展示了该算法，图3列出了算法的关键属性。图中剩余的属性会在本节分开阐述

![image-20200902005835715](https://wendajiang.github.io/pics/raft-extended/raft-2.png)

![image-20200902005912684](https://wendajiang.github.io/pics/raft-extended/raft-3.png)

Raft 通过首先选举一个 leader，然后让这个 leader 完全管理 replicated log 的方式实现共识（consensus）。leader 从客户端接收 log entries，在其他服务器上 replicate log entries ，并告诉其他服务器何时可以安全地将日志条目应用于