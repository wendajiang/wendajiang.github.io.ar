+++
template = "page.html"
date = "2021-04-06 21:13:52"
title = "时间，时间同步"
[taxonomies]
tags = ["time", "time sync"]

[extra]
mermaid = true
usemathjax = true
+++
<!--
mermaid example:
<div class="mermaid">
    mermaid program
</div>
-->

## 1.前言

由计算机网络系统组成的`分布式系统`，若想协调一致进行：IT行业的“整点开拍”、“秒杀”、“Leader选举”，通信行业的“同步组网”之类业务处理，毫秒级甚至微秒级的`时间同步`是重要基础之一。

## pre2 时间
Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix 系统、类Unix系统中，也在许多其他操作系统中被广告采用。

目前相当一部分操作系统使用32位二进制数字表示时间。此类系统的Unix时间戳最多可以使用到格林威治时间2038年01月19日03时14分07秒（二进制：*01111111 11111111 11111111 11111111*）。其后一秒，二进制数字会变为*10000000 00000000 00000000 00000000*，发生溢出错误，造成系统将时间误解为1901年12月13日20时45分52秒。这很可能会引起软件故障，甚至是系统瘫痪。使用64位二进制数字表示时间的系统（最多可以使用到格林威治时间292,277,026,596年12月04日15时30分08秒）则基本不会遇到这类溢出问题。

首先我们了解一下时间的相关概念，以及之间的区别，需要了解的时间概念有：
**本地时间**(locale time)
**格林威治时间**（Greenwich Mean Time **GMT**）
**时间协调时间** （Universal Time Coordinated **UTC**）
 
本地时间，显而易见不用解释了
先看看时间的标准：

1. 世界时
   世界时是最早的时间标准。在1884年，国际上将1s确定为全年内每日平均长度的1/8.64×104。以此标准形成的时间系统，称为世界是，即UT1。1972年国际上开始使用国际原子时标，从那以后，经过格林威治老天文台本初子午线的时间便被称为世界时，即UT2，或称格林威治时间（GMT），是对地球转速周期性差异进行校正后的世界时。
2. 原子时
   1967年，人们利用铯原子振荡周期极为规律的特性，研制出了高精度的原子时钟，将铯原子能级跃迁辐射9192631770周所经历的时间定为1s。现在用的时间就是1971年10月定义的国际原子时，是通过世界上大约200多台原子钟进行对比后，再由国际度量衡局时间所进行数据处理，得出的统一的原子时，简称TAI。
3. 世界协调时
   **世界协调时是以地球自转为基础的时间标准**。由于地球自转速度并不均匀，并非每天都是精确的86400原子s，因而导致了自转时间与世界时之间存在18个月有1s的误差。为纠正这种误差，国际地球自转研究所根据地球自转的实际情况对**格林威治时间**进行增减闰s的调整，与国际度量衡局时间所联合向全世界发布标准时间，这就是所谓的世界协调时（UTC:CoordinatdeUniversalTime）。UTC的表示方式为：年（y）、月（m）、日（d）、时（h）、分（min）、秒（s），均用数字表示。

GPS 系统中有两种时间区分，一为UTC，另一为LT（地方时）两者的区别为时区不同，UTC就是0时区的时间，地方时为本地时间，如北京为早上八点（东八区），UTC时间就为零点，时间比北京时晚八小时，以此计算即可
 通过上面的了解，我们可以认为格林威治时间就是时间协调时间（GMT=UTC），格林威治时间和UTC时间均用秒数来计算的。

而在我们平时工作当中看到的计算机日志里面写的时间大多数是用UTC时间来计算的，那么我们该怎么将UTC时间转化为本地时间便于查看日志，那么在作程序开发时又该怎么将本地时间转化为UTC时间呢？

下面就介绍一个简单而使用的工具，就是使用linux/unix命令date来进行本地时间和local时间的转化。
大家都知道，在计算机中看到的utc时间都是从（1970年01月01日 0:00:00)开始计算秒数的。所看到的UTC时间那就是从1970年这个时间点起到具体时间共有多少秒。

我们在编程中可能会经常用到时间，比如取得系统的时间（获取系统的年、月、日、时、分、秒，星期等），或者是隔一段时间去做某事，那么我们就用到一些时间函数。

### Linux 中的时间函数
linux下存储时间常见的有两种存储方式，一个是从**1970年到**现在经过了多少秒，一个是用一个结构来分别存储年月日时分秒的。
**time_t 这种类型就是用来存储从1970年到现在经过了多少秒**，要想更精确一点，可以用结构struct timeval，它精确到微妙。

```cpp
struct timeval {
  long tv_sec; //秒
  long tv_usec; //微秒
};
```

**而直接存储年月日的是一个结构：**

```cpp
struct tm
{
    int tm_sec;  /*秒，正常范围0-59， 但允许至61*/
    int tm_min;  /*分钟，0-59*/
    int tm_hour; /*小时， 0-23*/
    int tm_mday; /*日，即一个月中的第几天，1-31*/
    int tm_mon;  /*月， 从一月算起，0-11*/  1+p->tm_mon;
    int tm_year;  /*年， 从1900至今已经多少年*/  1900＋ p->tm_year;
    int tm_wday; /*星期，一周中的第几天， 从星期日算起，0-6*/
    int tm_yday; /*从今年1月1日到目前的天数，范围0-365*/
    int tm_isdst; /*日光节约时间的旗标*/
};
/*需要特别注意的是，年份是从1900年起至今多少年，而不是直接存储如2011年，月份从0开始的，0表示一月，星期也是从0开始的， 0表示星期日，1表示星期一。*/
```

下面介绍常用时间函数

```cpp
#include <time.h>
char *asctime(const struct tm* timeptr); //将结构中的信息转换为真实世界的时间，以字符串的形式显示
char *ctime(const time_t *timep); //将timep转换为真是世界的时间，以字符串显示，它和asctime不同就在于传入的参数形式不一样
double difftime(time_t time1, time_t time2);//返回两个时间相差的秒数
int gettimeofday(struct timeval *tv, struct timezone *tz); //返回当前距离1970年的秒数和微妙数，后面的tz是时区，一般不用
struct tm* gmtime(const time_t *timep); //将time_t表示的时间转换为没有经过时区转换的UTC时间，是一个struct tm结构指针
struct tm* localtime(const time_t *timep); //和gmtime类似，但是它是经过时区转换的时间。
time_t mktime(struct tm* timeptr); //将struct tm 结构的时间转换为从1970年至今的秒数
time_t time(time_t *t); //取得从1970年1月1日至今的秒数。
```
#### 一些例子：

```cpp
#include <time.h>
#include <stdio.h>

int main()
{
    time_t timep;
   
    time(&timep); /*获取time_t类型的当前时间*/
    /*用gmtime将time_t类型的时间转换为struct tm类型的时间按，／／没有经过时区转换的UTC时间
      然后再用asctime转换为我们常见的格式 Fri Jan 11 17:25:24 2008
    */
    printf("%s", asctime(gmtime(&timep)));
  	printf("%s", ctime(&timep));
		
  	//time, gmtime, asctime 所表示的时间都是UTC时间，只是数据类型不一样，
		// 而localtime, ctime 所表示的时间都是经过时区转换后的时间，它和你用系统命令date所表示的CST时间应该保持一致。
  	char *wday[] = {"sun", "mon", "tue", "wed", "thu", "fri", "sat"};
  	struct tm *p;
  	p = gmtime(&timep);
  	printf("%d/%d/%d", 1900 + p->tm_year, 1 + p->tm_mon, p->tm_day);
  	printf("%s %d:%d:%d\n", wday[p->tm_day], p->tm_hour, p->tm_min, p->tm_sec);
  	
  	// 这里面把UTC时间按转换为本地时间，然后再把本地时间转换为UTC时间，它们转换的结果保持一致。
  	printf("time():%d\n",timep);
    p = localtime(&timep); /*转换为本地的tm结构的时间按*/
    timep = mktime(p); /*重新转换为time_t类型的UTC时间，这里有一个时区的转换*/ //by lizp 错误，没有时区转换， 将struct tm 结构的时间转换为从1970年至p的秒数
    printf("time()->localtime()->mktime(): %d\n", timep);
  	
  
  	// 从这里面我们可以看出，转换后时间不一致了，计算一下，整整差了8个小时( (1200075192-1200046392)/3600 = 8)，说明mktime会把本地时间转换为UTC时间，这里面本来就是UTC时间，于是再弄个时区转换，结果差了8个小时，用的时候应该注意。
  	printf("time():%d\n",timep);
    p = gmtime(&timep); /*得到tm结构的UTC时间*/
    timep = mktime(p); /*转换，这里会有时区的转换*/ //by lizp 错误，没有时区转换， 将struct tm 结构的时间转换为从1970年至p的秒数
    printf("time()->gmtime()->mktime(): %d\n", timep);
  
  	
    return 0;
}
```

strftime() 函数将时间格式化
我们可以使用strftime（）函数将时间格式化为我们想要的格式。它的原型如下：

```cpp
size_t strftime(
   char *strDest,
   size_t maxsize,
   const char *format,
   const struct tm *timeptr
);
```

我们可以根据format指向字符串中格式命令把timeptr中保存的时间信息放在strDest指向的字符串中，最多向strDest中存放maxsize个字符。该函数返回向strDest指向的字符串中放置的字符数。
函数strftime()的操作有些类似于sprintf()：识别以百分号(%)开始的格式命令集合，格式化输出结果放在一个字符串中。格式化命令说明串 strDest中各种日期和时间信息的确切表示方法。格式串中的其他字符原样放进串中。格式命令列在下面，它们是区分大小写的。

| 符号 | 含义                                                 |
| ---- | ---------------------------------------------------- |
| %a   | 星期几的简写                                         |
| %A   | 星期几的全称                                         |
| %b   | 月分的简写                                           |
| %B   | 月份的全称                                           |
| %c   | 标准的日期的时间串                                   |
| %C   | 年份的后两位数字                                     |
| %d   | 十进制表示的每月的第几天                             |
| %D   | 月/天/年                                             |
| %e   | 在两字符域中，十进制表示的每月的第几天               |
| %F   | 年-月-日                                             |
| %g   | 年份的后两位数字，使用基于周的年                     |
| %G   | 年分，使用基于周的年                                 |
| %h   | 简写的月份名                                         |
| %H   | 24小时制的小时                                       |
| %I   | 12小时制的小时                                       |
| %j   | 十进制表示的每年的第几天                             |
| %m   | 十进制表示的月份                                     |
| %M   | 十时制表示的分钟数                                   |
| %n   | 新行符                                               |
| %p   | 本地的AM或PM的等价显示                               |
| %r   | 12小时的时间                                         |
| %R   | 显示小时和分钟：hh:mm                                |
| %S   | 十进制的秒数                                         |
| %t   | 水平制表符                                           |
| %T   | 显示时分秒：hh:mm:ss                                 |
| %u   | 每周的第几天，星期一为第一天 （值从0到6，星期一为0） |
| %U   | 第年的第几周，把星期日做为第一天（值从0到53）        |
| %V   | 每年的第几周，使用基于周的年                         |
| %w   | 十进制表示的星期几（值从0到6，星期天为0）            |
| %W   | 每年的第几周，把星期一做为第一天（值从0到53）        |
| %x   | 标准的日期串                                         |
| %X   | 标准的时间串                                         |
| %y   | 不带世纪的十进制年份（值从0到99）                    |
| %Y   | 带世纪部分的十制年份                                 |
| %z   | ，%Z 时区名称，如果不能得到时区名称则返回空字符。    |
| %%   | 百分号                                               |

例子 

```cpp
#include "time.h"
#include "stdio.h"
int main(void)
{
    struct tm *ptr;
    time_t lt;
    char str[80];
    lt=time(NULL);
    ptr=localtime(&lt);
    strftime(str,sizeof(str),"It is now %I %p",ptr);
    printf(str);
    return 0;
}
//其运行结果为：
// It is now 4PM
// 而下面的程序则显示当前的完整日期：
#include<stdio.h>
#include<string.h>
#include<time.h>
int main( void )
{
	struct tm *newtime;
  char tmpbuf[128];
  time_t lt1;
	time( &lt1 );
  newtime=localtime(&lt1);
	strftime( tmpbuf, sizeof(tmpbuf), "Today is %A, day %d of %B in the year %Y.\n", newtime);
  printf(tmpbuf);
	return 0;
}
```



## 2.术语描述

### 2.0 世界时

`世界时UT`，可以简单理解为按照地球自转一周来计量24小时的时间标准，由于地球自转速率的变化，世界时的秒长会有微小的变化，每天的快慢可以达到千分之几秒。

### 2.1 TAI时间

世界时不准，因此国际组织定义了`TAI时间`,即国际原子时（ International Atomic Time），其起点是1958年的开始（世界时UT），以铯原子钟走秒连续计时的时间。

### 2.2 UTC时间

计算机网络普遍使用的`UTC时间（协调世界时,Coordinated Universal Time）`，由国际计量局BIPM综合全世界多个守时实验室的钟组计算得到，为了使UTC时间与地球自转1天的时间（世界时UT）协调一致，每隔1到2年， BIPM会通告在UTC时间6月30日或12月31日最后一分钟“加一秒”或“减一秒”等闰秒调整。也就是说，UTC时间会出现60秒或少了59秒的情况。

最近一次闰秒是UTC时间2015年6月底：

> 2015 年6月30日，23时 59分 59秒
> 2015 年6月30日，23时 59分 60秒
> 2015 年7月 1日， 0时 0分 0秒

由于存在闰秒，UTC时间与TAI时间是有差别的，UTC = TAI - n，这个n现在（2016年1月）是36秒，也就是说UTC时间比TAI时间慢了36秒。

### 2.3 北京时间

北京时间也就是`东八区时间`，在UTC时间基础上加8小时，中国的北京标准时间由位于陕西的国家授时中心发播。

### 2.4 GPS时间

由GPS系统通过卫星信号发播的`原子时间`，GPS时间用自1980年1月6日零点（UTC时间）起的星期数和该星期内内的秒数来表示。

工程上，GPS接收机会根据闰秒数将GPS时间换算为我们通常使用的UTC时间。GPS时间的源头是美国海军天文台的守时原子钟组。

### 2.5 北斗（BDS）时间

由北斗卫星导航系统通过卫星信号发播的`原子时间`，同样，北斗接收机会根据闰秒数将北斗时间换算为我们通常使用的UTC时间。

北斗时间的时钟源是位于北京的解放军`时频中心`的守时原子钟组，陕西的国家授时中心好尴尬:(。

### 2.6 频率

时间的导数就是`频率`，机械发条、石英晶体振荡器、原子钟等各种时钟源通过产生频率信号，按照频率均匀打拍计数，模拟时间的等间隔流逝，就有了可见的“时间”。

### 2.7 频率准确度

手表有准和不准的，反映的就是频率准不准，时钟频率和标准频率的偏差可以用`频率准确度`来衡量。1E-9量级表示1秒会差1ns，我们使用的个人电脑，它的守时时钟是个32. 768kHz的石英晶振，准确度大概只有2E-5量级（20ppm），也就是说1秒会差0.02ms，1天会跑偏大概2秒。

### 2.8 时间同步

广义的“时间同步”包括的`时间和频率`的同步。上级时钟将时间频率信号通过各种有线（以太网、SDH数字网、同轴电缆、电话等）、无线（卫星、长波、电台、微波、WIFI、Zigbee等）链路传递给下级时钟，下级时钟接受时间频率信息后，与上级时钟保持相位、频率的一致。

## 3.时间同步原理

### 3.1 单向授时

上级时钟主动发播时间信息，下级用户端被动接受时间信息，并调整本地时钟使时差控制在一定范围内。

要想提高授时精度，用户端必须计算出时间信息在传播链路中的延时，GPS/北斗等卫星授时，可以通过用户端定位与卫星之间距离确定电磁传输延时，消除大部分误差，而电缆、网络等如果是单向授时方式就无法准确计算单向链路时延了。

### 3.2 双向授时

用户端将接受的时间信息原路返回给上级时钟服务端，服务端将往返时间除以二即得到单向链路时延，再把单向时延告诉客户端，在此基础上，客户端得到服务端更准确的时间信息。比如：北斗单向卫星授时精度100ns，双向卫星授时精度可做到20ns。

### 3.3 网络时间同步

网络时间同步，特指在计算机网络内的服务器与客户端之间利用`网络报文`交换实现的时间同步。

鉴于计算机网络传输路径的不确定性和中间路由交换设备转发报文时间的不确定性，通过单播或多播实现的单向网络授时是不可靠的。因此，前辈们发明的网络时间同步技术NTP/PTP等，基本原理都是通过对网络报文打时间戳（标记），往返交换报文计算传输时延和同步误差。

### 3.4 频率同步

`频率同步`指的是主从时钟的频率误差保持在一定范围内，频率同步有2种类型:

第1种是直接传递模拟频率信号，比如用电缆或光缆传递10MHz、5Mhz、2.048MHz等标准频率，或者传递bit位宽脉冲；

第2种是通过测量得到的主从时钟时差，通过锁定主从相差实现频率锁定（PLL），或者间接计算频率偏差，完成频率修正。

## 4.计算机网络时间同步

计算机网络时间同步只是时间同步的一种应用场景，其时间传递的链路可能是SDH网、以太网、WIFI无线网络等。

### 4.1 NTP

[NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol)（Network Time Protocol）从1985年诞生来，目前仍在在大部分的计算机网络中起着同步系统时间的作用。

- 基本原理

> 服务器和客户端之间通过二次报文交换，确定主从时间误差，客户端校准本地计算机时间，完成时间同步，有条件的话进一步校准本地时钟频率。

- 时间同步过程

> 服务器在UDP的132端口提供授时服务，客户端发送附带T1时间戳（Timestamp）的查询报文给服务器，服务器在该报文上添加到达时刻T2和响应报文发送时刻T3，客户端记录响应报到达时刻T4。

贴个维基的图：

> ![image-20210406211933550](https://wendajiang.github.io/pics/time_utc_timesync_etc/image-20210406211933550.png)

- 时差计算

> 维基这个图中用蓝色标注了主从直接来回链路的`时延Sigma`：
> `Sigma = (t4-t1)-(t3-t2)`
> 因此，假设来回网络链路是对称的，即传输时延相等，那么可以计算客户端与服务器之间的`时间误差Delta`为：
> `Delta = t2-t1-Sigma/2=((t2-t1)+(t3-t4))/2`
>
> 客户端调整自身的时间Delta，即可完成一次时间同步。

- 计时方式

> NTP采用UTC时间计时，`NTP时间戳`包括自1900-01-01 00:00:00开始的UTC总秒数，当前秒的亚秒数。
>
> 当正闰秒时，60秒和下一分钟的0秒的NTP总秒数一致的，因此NTP报文专门定义了闰秒指示域来提示。

- 误差分析

> 局域网内计算机利用NTP协议进行时间同步，时间同步精度在5ms左右，主要误差包括：
>
> > 1）计算机打时间戳的位置在应用层，受协议栈缓存、任务调度等影响，不能在网络报文到来时马上打戳；
> > 2）各种中间网络传输设备带来的传输时延不确定性以及链路的不对称性，将进一步降低NTP时间同步精度。

### 4.2 PTP

为克服NTP的各种缺点，PTP(Precision Time Protocol，精确时间同步协议)应运而生，最新协议是[IEEE1588v2](https://en.wikipedia.org/wiki/Precision_Time_Protocol)，可实现亚微秒量级的时间同步精度。

- 基本原理

> 主从节点在网络链路层打时间戳，利用支持IEEE1588协议的PHY片，精准记录时间同步网络报文接受或发送的时刻。交换机、路由器等网络中间节点准确记录时间同步报文在其中停留的时间，实现对链路时延的准确计算。

- 时间同步过程

> PTP默认使用`组播`协议，二层或四层UDP组播都可以，一般我们使用基于UDP组播，使用319和320两个端口。
>
> PTP定义了三种角色：`OC、BC和TC`。我们一般接触的是OC：主时钟和从时钟，交换机、路由器一般是BC或TC。
>
> 由于硬件性能有限，网络报文发送时记录的时刻信息，可以在随后的Follow_Up跟随报文中发出，这就是PTP的双步模式(Two-step)。

下图是两OC主从时钟之间的同步过程：

> ![image-20210406211952436](https://wendajiang.github.io/pics/time_utc_timesync_etc/image-20210406211952436.png)
>
> - a.主时钟向从时钟发送Sync报文，并在本地记录发送时间t1；从时钟收到该报文后，记录接收时间t2。
> - b.时钟发送Sync报文之后，紧接着发送一个携带有t1的Follow_Up报文。
> - c.从时钟向主时钟发送Delay_Req报文，用于发起反向传输延时的计算，并在本地记录发送时间t3；主时钟收到该报文后，记录接收时间t4。
> - d.主时钟收到Delay_Req报文之后，回复一个携带有t4的Delay_Resp报文。

- 时差计算

> 与NTP一样的原理，从时钟根据拥有的t1～t4这四个时间戳，由此可计算出主、从时钟间的往返总延时为：
> `Sigma = (t4-t1)-(t3-t2)`
>
> 假设网络是对称的，从时钟相对于主时钟的时钟偏差为：
> `Delta = t2-t1-Sigma/2=((t2-t1)+(t3-t4))/2`

- 计时方式

> 与NTP不同，PTP采用TAI世界原子时间计时，而且PTP计时的起点与unix时间一致，即UTC时间1970年1月1日0点。
>
> PTP主钟会告知从钟，当前UTC相对于TAI的累计偏移量，从钟据此计算当前准确的UTC时间。

- 误差分析

> PTP能准确记录报文发送和接受的时间，也能计算中间链路的延时，剩下影响最大的就是`网络链路的不对称性`了。
>
> 在实际工程中，网络中间链路设备不支持PTP协议，大大降低了PTP的同步精度。目前，PTP主要应用在通信同步网、电力同步网等行业网络系统里。

- 同步拓扑

> PTP域中所有的时钟节点都按一定层次组织在一起，可通过BMC（Best Master Clock，最佳主时钟）协议动态选举出最优时钟，最优时钟的时间最终将被同步到整个PTP域中。
>
> BMC算法与STP（Spaning Tree Protocl）生成树协议类似，最终形成`无环路`的树形网络拓扑，且都是动态选举，能适应最佳主时钟切换的变化。

- 扩展应用——PTP over SDH

> 充分利用各行业已有的SDH通信网络，利用`PTP-E1信号`转换设备，架设PTP同步网络，除了需要考虑链路倒换问题之外，SDH网络的时延稳定性可大幅提升网络时间同步精度。

### 4.3 SyncE同步以太网

以太网最早只能传输数据信号，有另外独立的频率同步网络，随着以太网的快速发展，SyncE（Synchronized Ethernet）[同步以太网](http://www.embedded.com/design/prototyping-and-development/4008244/An-introduction-to-Synchronized-Ethernet)技术诞生后，企业们有了新的选择。

- 基本原理

> 时钟节点利用以太网（1000M、1G、10G等）物理层的空闲间隙，传递`位宽时钟信号`，实现时钟频率信号（25M、125M等）的自上而下传递。

- 协议控制

> 类似于SDH网络等时间间隔传递的SSM同步状态信息，同步以太网（Sync-E）利用链路层[ESMC协议](https://en.wikipedia.org/wiki/Synchronous_Ethernet)封装传递SSM信息，SSM信息包含时钟质量信息，接收端据此选择合适的上级网络时钟。

- 应用

> 一般商业PHY片提供SyncE功能选项，开启该功能模式，即可利用PHY恢复出来的频率信号，校准本地时钟频率或分频后用于本地计时。

## 更新记录
2021-05-07 增加 pre2 一节