<!doctype html><html lang=en-US><head><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><link as=font crossorigin href=https://wendajiang.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 rel=preload type=font/woff2><link as=font crossorigin href=https://wendajiang.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 rel=preload type=font/woff2><link href=https://wendajiang.github.io/main.css rel=stylesheet><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>How C++ resolves a function call | 「靡不有初，鲜克有终」</title><meta content="blog of david" name=description><link href=https://wendajiang.github.io/how-cpp-resolves-a-function-call/ rel=canonical><meta content="How C++ resolves a function call" property=og:title><meta content="blog of david" property=og:description><meta content=article property=og:type><meta content=https://wendajiang.github.io/how-cpp-resolves-a-function-call/ property=og:url><meta content=https://wendajiang.github.io/david.png property=og:image><meta content=2023-05-05T18:21:42 property=og:updated_time><meta content="How C++ resolves a function call" property=og:site_name><meta content=en_US property=og:locale><script type=application/ld+json>
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/how-cpp-resolves-a-function-call/"
      },
      "headline": "How C++ resolves a function call",
      "image": ,
      "datePublished": "2023-05-05T18:21:42",
      "dateModified": "2023-05-05T18:21:42",
      "author": {
        "@type": "Organization",
        "name": "How C++ resolves a function call"
      },
      "publisher": {
        "@type": "Organization",
        "name": "How C++ resolves a function call",
        
        "logo": {
          "@type": "ImageObject",
          "url": "/david.png"
        }
        
      },
      "description": "blog of david"
    }
    </script><script type=application/ld+json>
  {
    "@context": "http://schema.org",
    "@type": "BreadcrumbList",
    
      
      
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
          {
            "@type": "ListItem",
            "position":  1 ,
            "name": "Home",
            "item": "https://wendajiang.github.io/"
          },
          
          
          {
            "@type": "ListItem",
            "position":  2 ,
            "name": "How Cpp Resolves A Function Call",
            "item": "https://wendajiang.github.io/how-cpp-resolves-a-function-call/"
          },
        
      
    
  }
</script><meta content=#fff name=theme-color><link href=https://wendajiang.github.io/david.png rel=apple-touch-icon sizes=180x180><link href=https://wendajiang.github.io/david.png rel=icon sizes=32x32 type=image/png><link href=https://wendajiang.github.io/david.png rel=icon sizes=16x16 type=image/png><link crossorigin href=https://wendajiang.github.io/site.webmanifest rel=manifest><link href=https://wendajiang.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq rel=stylesheet><script crossorigin defer integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script crossorigin defer integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI onload=renderMathInElement(document.body); src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script>function initMermaid(){var a={startOnLoad:true,theme:"neutral",flowchart:{useMaxWidth:true,htmlLabels:true}};mermaid.initialize(a);window.mermaid.init(undefined,document.querySelectorAll('.mermaid'))}</script><script async onload=initMermaid() src=https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js></script><body class="blog single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" id=menu-btn type=checkbox><label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://wendajiang.github.io>「靡不有初，鲜克有终」</a><button aria-label="Toggle mode" class="btn btn-link order-2 order-md-4" id=mode type=button><span class=toggle-dark><svg class="feather feather-moon" viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></span> <span class=toggle-light><svg class="feather feather-sun" viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></span></button><ul class="navbar-nav fork-me order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/wendajiang><svg class="feather feather-github" viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg><span class="ms-2 visually-hidden">GitHub</span></a></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/books/effective-modern-cpp/>Books</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/turtle/>Turtle</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/essay/>Essay</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/QA/>Q&A</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/tags>Tags</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/archive>Archive</a></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container" role=document><div class=content><div class="row justify-content-center"><nav aria-label="Secondary navigation" class="books-toc d-none d-xl-block col-xl-3"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=https://wendajiang.github.io/how-cpp-resolves-a-function-call/#name-lookup>Name Lookup</a><li><a href=https://wendajiang.github.io/how-cpp-resolves-a-function-call/#special-handling-of-function-template>Special handling of function template</a><li><a href=https://wendajiang.github.io/how-cpp-resolves-a-function-call/#overload-resolution>Overload resolution</a></li><ul><li><a href=https://wendajiang.github.io/how-cpp-resolves-a-function-call/#tiebreakers>Tiebreakers</a></ul><li><a href=https://wendajiang.github.io/how-cpp-resolves-a-function-call/#after-the-function-call-is-resolved>After the function call is resolved</a></ul></nav></div></nav><div class="col-md-12 col-lg-10 col-xxl-8"><article><div class=blog-header><h1>How C++ resolves a function call</h1><p><small>Posted 2023-05-05 18:21:42 ‐ <strong>7 min read</strong></small><p><div class=category-area>「 <a href=https://wendajiang.github.io/tags/reprint> <div class=category>reprint</div> </a> 」</div></div><p><a href=https://preshing.com/20210315/how-cpp-resolves-a-function-call/>src</a><p><img alt=function_call src=https://wendajiang.github.io/pics/how_cpp_resolves_a_function_call/function_call.png><p>This is how the compiler, given a function call expression, figures out exactly which function to call. These steps are enshrined in the C++ standard. Every C++ compiler must follow them, and the whole thing happens at compile time for every function call expression evaluated by the program.<p>I imagine the overall intent of the algorithm is to "do what the programmer expects", and to some extent, it's successful at that. You can get pretty far ignoring the algorithm altogether.<h1 id=name-lookup><a aria-label="Anchor link for: name-lookup" class=zola-anchor href=#name-lookup>Name Lookup</a></h1><pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>namespace </span><span>galaxy </span><span style=color:#fff>{
</span><span>  </span><span style=font-style:italic;color:#8be9fd>struct </span><span>Asteroid </span><span style=color:#fff>{
</span><span>    </span><span style=font-style:italic;color:#8be9fd>float</span><span> radius </span><span style=color:#ff79c6>= </span><span style=color:#bd93f9>12</span><span>;
</span><span>  </span><span style=color:#fff>}</span><span>;
</span><span>  </span><span style=font-style:italic;color:#8be9fd>void </span><span style=color:#50fa7b>blast</span><span>(Asteroid</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>ast</span><span>, </span><span style=font-style:italic;color:#8be9fd>float </span><span style=font-style:italic;color:#ffb86c>force</span><span>);
</span><span style=color:#fff>}
</span><span>
</span><span style=font-style:italic;color:#8be9fd>struct </span><span>Target </span><span style=color:#fff>{
</span><span>  galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>*</span><span> ast;
</span><span>  </span><span style=color:#50fa7b>Target</span><span>(galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>ast</span><span>): </span><span style=color:#fff>ast</span><span>{ast} </span><span style=color:#fff>{}
</span><span>  </span><span style=color:#ff79c6>operator</span><span> galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>*</span><span>() </span><span style=color:#ff79c6>const </span><span style=color:#fff>{</span><span style=color:#ff79c6>return</span><span> ast;</span><span style=color:#fff>}
</span><span style=color:#fff>}</span><span>;
</span><span>
</span><span style=font-style:italic;color:#8be9fd>bool </span><span style=color:#50fa7b>blast</span><span>(Target </span><span style=font-style:italic;color:#ffb86c>target</span><span>);
</span><span style=font-style:italic;color:#8be9fd>template</span><span><</span><span style=font-style:italic;color:#8be9fd>typename</span><span> T> </span><span style=font-style:italic;color:#8be9fd>void </span><span style=color:#50fa7b>blast</span><span>(T</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>obj</span><span>, </span><span style=font-style:italic;color:#8be9fd>float </span><span style=font-style:italic;color:#ffb86c>force</span><span>);
</span><span>
</span><span style=font-style:italic;color:#8be9fd>void </span><span style=color:#50fa7b>play</span><span>(galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>ast</span><span>) </span><span style=color:#fff>{
</span><span>  </span><span style=color:#50fa7b>blast</span><span>(ast, </span><span style=color:#bd93f9>100</span><span>);
</span><span style=color:#fff>}
</span></code></pre><p>There are three main types of name lookup:<ul><li>Member name lookup occurs when a name is to the right of a <code>a</code> or <code>-></code> token, as in <code>foo->bar</code>. This type of lookup is used to locate class members<li>Qualified name lookup occurs when a name has a <code>::</code> token in it, like <code>std::sort</code>. This type of name is explicit. The part to the right of the <code>::</code> token is only looked up in the scope identified by the left part.<li>Unqualified name lookup is neither of those. When the compiler sees an unqualified name, like <code>blast</code>, it looks for matching declarations in various scopes depending on the context. There's a detailed set of rules that determine exactly where the compiler should look.</ul><p>In our case, we have an unqualified name. Now when name lookup is performed for a function call expression, the compiler may find multiple declarations. Let's call these declarations <strong>candidates</strong>. In the example above, the compiler finds three candidates:<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#8be9fd>void </span><span>galaxy</span><span style=color:#ff79c6>::</span><span style=color:#50fa7b>blast</span><span>(galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>ast</span><span>, </span><span style=font-style:italic;color:#8be9fd>float </span><span style=font-style:italic;color:#ffb86c>force</span><span>);
</span><span style=font-style:italic;color:#8be9fd>bool </span><span style=color:#50fa7b>blast</span><span>(Target </span><span style=font-style:italic;color:#ffb86c>target</span><span>);
</span><span style=font-style:italic;color:#8be9fd>template</span><span><</span><span style=font-style:italic;color:#8be9fd>typename</span><span> T> </span><span style=font-style:italic;color:#8be9fd>void </span><span style=color:#50fa7b>blast</span><span>(T</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>obj</span><span>, </span><span style=font-style:italic;color:#8be9fd>float </span><span style=font-style:italic;color:#ffb86c>force</span><span>);
</span></code></pre><p>The first candidate, deserves extra attention because is demenstrates a feature of C++ that's easy to overlook: argument-dependent lookup, or <strong>ADL</strong> for short. Here’s a quick summary in case you’re in the same boat. Normally, you wouldn’t expect this function to be a candidate for this particular call, since it was declared inside the <code>galaxy</code> namespace and the call comes from <em>outside</em> the <code>galaxy</code> namespace. There’s no <code>using namespace galaxy</code> directive in the code to make this function visible, either. So why is this function a candidate?<p>The reason is because any time you use an unqualified name in a function call – and the name doesn’t refer to a class member, among other things – ADL kicks in, and name lookup becomes more greedy. Specifically, in addition to the usual places, the compiler looks for candidate functions <em>in the namespaces of the argument types</em> – hence the name “argument-dependent lookup”.<p>The <a href=https://en.cppreference.com/w/cpp/language/adl>complete set of rules governing ADL</a> is more nuanced than what I’ve described here, but the key thing is that ADL only works with unqualified names. For qualified names, which are looked up in a single scope, there’s no point. ADL also works when overloading built-in operators like <code>+</code> and <code>==</code>, which lets you take advantage of it when writing, say, a math library.<p>Interestingly, there are cases where member name lookup can find candidates that unqualified name lookup can’t. See <a href=https://eli.thegreenplace.net/2012/02/06/dependent-name-lookup-for-c-templates>this post by Eli Bendersky</a> for details about that.<h1 id=special-handling-of-function-template><a aria-label="Anchor link for: special-handling-of-function-template" class=zola-anchor href=#special-handling-of-function-template>Special handling of function template</a></h1><p>Some of the candidates found by name lookup are functions; others are function <em>templates</em>. There’s just one problem with function templates: You can’t call them. You can only call functions. Therefore, after name lookup, the compiler goes through the list of candidates and tries to turn each function template into a function.<h1 id=overload-resolution><a aria-label="Anchor link for: overload-resolution" class=zola-anchor href=#overload-resolution>Overload resolution</a></h1><p>At this stage, all of the function templates found during name lookup are gone, and we’re left with a nice, tidy set of <strong>candidate functions</strong>. This is also referred to as the <strong>overload set</strong>. Here’s the updated list of candidate functions for our example:<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#8be9fd>void </span><span>galaxy</span><span style=color:#ff79c6>::</span><span style=color:#50fa7b>blast</span><span>(galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>ast</span><span>, </span><span style=font-style:italic;color:#8be9fd>float </span><span style=font-style:italic;color:#ffb86c>force</span><span>);
</span><span style=font-style:italic;color:#8be9fd>bool </span><span style=color:#50fa7b>blast</span><span>(Target </span><span style=font-style:italic;color:#ffb86c>target</span><span>);
</span><span style=font-style:italic;color:#8be9fd>void </span><span style=color:#50fa7b>blast</span><span>&LTgalaxy</span><span style=color:#ff79c6>::</span><span>Asteroid>(galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>obj</span><span>, </span><span style=font-style:italic;color:#8be9fd>float </span><span style=font-style:italic;color:#ffb86c>force</span><span>);
</span></code></pre><p>The next two steps narrow down this list even further by determining which of the candidate functions are <strong>viable</strong> – in other words, which ones <em>could</em> handle the function call.<p>After using the caller’s arguments to filter out incompatible candidates, the compiler proceeds to check whether each function’s <a href=https://en.cppreference.com/w/cpp/language/constraints#Constraints><strong>constraints</strong></a> are satisfied, if there are any. Constraints are a new feature in C++20. They let you use custom logic to eliminate candidate functions (coming from a class template or function template) without having to resort to SFINAE. They’re also supposed to give you better error messages. Our example doesn’t use constraints, so we can skip this step. (Technically, the standard says that constraints are also checked earlier, during <a href=https://eel.is/c++draft/temp.deduct#general-5>template argument deduction</a>, but I skipped over that detail. Checking in both places helps ensure the best possible error message is shown.)<h2 id=tiebreakers><a aria-label="Anchor link for: tiebreakers" class=zola-anchor href=#tiebreakers>Tiebreakers</a></h2><p>At this point in out example, we're down to two viable functions. Either of them could handle the original function call just fine:<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#8be9fd>void </span><span>galaxy</span><span style=color:#ff79c6>::</span><span style=color:#50fa7b>blast</span><span>(galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>ast</span><span>, </span><span style=font-style:italic;color:#8be9fd>float </span><span style=font-style:italic;color:#ffb86c>force</span><span>);
</span><span style=font-style:italic;color:#8be9fd>void </span><span style=color:#50fa7b>blast</span><span>&LTgalaxy</span><span style=color:#ff79c6>::</span><span>Asteroid>(galaxy</span><span style=color:#ff79c6>::</span><span>Asteroid</span><span style=color:#ff79c6>* </span><span style=font-style:italic;color:#ffb86c>obj</span><span>, </span><span style=font-style:italic;color:#8be9fd>float </span><span style=font-style:italic;color:#ffb86c>force</span><span>);
</span></code></pre><p>Indeed, if either of the above functions was the only viable one, it <em>would</em> be the one that handles the function call. But because there are two, the compiler must now do what it always does when there are multiple viable functions: It must determine which one is the <strong>best viable function</strong>. To be the best viable function, one of them must “win” against every other viable function as decided by a <a href=https://en.cppreference.com/w/cpp/language/overload_resolution#Best_viable_function>sequence of tiebreaker rules</a>.<p><strong>First tiebreaker: Better-matching parameters wins</strong><p>the two method are identical parameter types. So neither is better than the other.<p><strong>Second tiebreaker: Non-template function wins</strong><p>So the first method wins.<p><strong>Third tiebreaker: More specialized template wins</strong><p>If it wasn't found, we would move on to the third tiebreaker.<p>There are <a href=https://en.cppreference.com/w/cpp/language/overload_resolution#Best_viable_function>several more tiebreakers</a> in addition to the ones listed here. For example, if both the <a href=https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/>spaceship <code><=></code> operator</a> and an overloaded comparison operator such as <code>></code> are viable, C++ prefers the comparison operator. And if the candidates are user-defined conversion functions, there are other rules that take higher priority than the ones I’ve shown. Nonetheless, I believe the three tiebreakers I’ve shown are the most important to remember.<p>Needless to say, if the compiler checks every tiebreaker and doesn’t find a single, unambiguous winner, compilation fails with an error message similar to the one shown near the beginning of this post.<h1 id=after-the-function-call-is-resolved><a aria-label="Anchor link for: after-the-function-call-is-resolved" class=zola-anchor href=#after-the-function-call-is-resolved>After the function call is resolved</a></h1><p>We’ve reached the end of our journey. The compiler now knows exactly which function should be called by the expression <code>blast(ast, 100)</code>. In many cases, though, the compiler has more work to do after resolving a function call:<ul><li>If the function being called is a class member, the compiler must check that member’s <a href=https://en.cppreference.com/w/cpp/language/access>access specifiers</a> to see if it’s accessible to the caller.<li>If the function being called is a template function, the compiler attempts to <a href=https://en.cppreference.com/w/cpp/language/function_template#Implicit_instantiation>instantiate</a> that template function, provided its definition is visible.<li>If the function being called is a <a href=https://en.cppreference.com/w/cpp/language/virtual>virtual function</a>, the compiler generates special machine instructions so that the correct override will be called at runtime.</ul></article></div></div></div><div id=gitalk-container></div><link href=https://unpkg.com/gitalk/dist/gitalk.css rel=stylesheet><script src=https://unpkg.com/gitalk/dist/gitalk.min.js></script><script>var gitalk=new Gitalk({id:'How C++ resolves a function call',clientID:'a17500877ddbb2dd70b9',clientSecret:'77e1c5816e97e2473c0a617bd0e3ece99f33559f',repo:'wendajiang.github.io',owner:'wendajiang',admin:['wendajiang'],perPage:50});gitalk.render('gitalk-container')</script></div><script defer src=https://wendajiang.github.io/js/main.js></script><script defer src=https://wendajiang.github.io/plugins/elasticlunr.min.js></script><script defer src=https://wendajiang.github.io/search_index.en.js></script><script defer src=https://wendajiang.github.io/js/search.js></script>