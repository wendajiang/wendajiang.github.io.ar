<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>「靡不有初，鲜克有终」 - ABA</title>
    <subtitle>blog of david</subtitle>
    <link href="https://wendajiang.github.io/tags/ABA/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://wendajiang.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2021-04-03T11:46:30+00:00</updated>
    <id>https://wendajiang.github.io/tags/ABA/atom.xml</id>
    <entry xml:lang="en">
        <title>无锁算法</title>
        <published>2021-04-03T11:46:30+00:00</published>
        <updated>2021-04-03T11:46:30+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://wendajiang.github.io/lock-free/" type="text/html"/>
        <id>https://wendajiang.github.io/lock-free/</id>
        <content type="html">&lt;!--
mermaid example:
&lt;div class=&quot;mermaid&quot;&gt;
    mermaid program
&lt;&#x2F;div&gt;
--&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;an-introduction-to-lock-free-programming&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-introduction-to-lock-free-programming&quot; aria-label=&quot;Anchor link for: an-introduction-to-lock-free-programming&quot;&gt;An Introduction to Lock-Free Programming&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;preshing.com&#x2F;20120612&#x2F;an-introduction-to-lock-free-programming&#x2F;&quot;&gt;链接&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-is-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-it&quot; aria-label=&quot;Anchor link for: what-is-it&quot;&gt;what is it&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;lock_free&#x2F;image-20210405160006637.png&quot; alt=&quot;image-20210405160006637&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;techniques&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#techniques&quot; aria-label=&quot;Anchor link for: techniques&quot;&gt;techniques&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;lock_free&#x2F;image-20210405160054136.png&quot; alt=&quot;image-20210405160054136&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;qi-ta&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#qi-ta&quot; aria-label=&quot;Anchor link for: qi-ta&quot;&gt;其他&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;h3 id=&quot;yi-wu-suo-suan-fa&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#yi-wu-suo-suan-fa&quot; aria-label=&quot;Anchor link for: yi-wu-suo-suan-fa&quot;&gt;一、无锁算法&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。实现非阻塞同步的方案称为“无锁编程算法”（ Non-blocking algorithm）。
相对应的，独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。
使用lock实现线程同步有很多缺点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;产生竞争时，线程被阻塞等待，无法做到线程实时响应。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;dead lock，死锁。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;live lock。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;优先级翻转。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用不当，造成性能下降。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;当然在部分情况下，目前来看，无锁编程并不能替代 lock。 &lt;&#x2F;p&gt;
&lt;h3 id=&quot;er-shi-xian-ji-bie&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#er-shi-xian-ji-bie&quot; aria-label=&quot;Anchor link for: er-shi-xian-ji-bie&quot;&gt;二、实现级别&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;非同步阻塞的实现可以分成三个级别：wait-free&#x2F;lock-free&#x2F;obstruction-free。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;wait-free
是最理想的模式，整个操作保证每个线程在有限步骤下完成。
保证系统级吞吐（system-wide throughput）以及无线程饥饿。
截止2011年，没有多少具体的实现。即使实现了，也需要依赖于具体CPU。&lt;&#x2F;li&gt;
&lt;li&gt;lock-free
允许个别线程饥饿，但保证系统级吞吐。确保至少有一个线程能够继续执行。
wait-free的算法必定也是lock-free的。&lt;&#x2F;li&gt;
&lt;li&gt;obstruction-free
在任何时间点，一个线程被隔离为一个事务进行执行（其他线程suspended），并且在有限步骤内完成。在执行过程中，一旦发现数据被修改（采用时间戳、版本号），则回滚。也叫做乐观锁，即乐观并发控制(OOC)。事务的过程是：1读取，并写时间戳；2准备写入，版本校验；3校验通过则写入，校验不通过，则回滚。
lock-free必定是obstruction-free的。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;san-cassuan-fa&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#san-cassuan-fa&quot; aria-label=&quot;Anchor link for: san-cassuan-fa&quot;&gt;三、CAS算法&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项 乐观锁 技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
java.util.concurrent.atomic中的AtomicXXX，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作，而在java.util.concurrent中的大多数类在实现时都直接或间接的使用了这些原子变量类，这些原子变量都调用了 sun.misc.Unsafe 类库里面的 CAS算法，用CPU指令来实现无锁自增，JDK源码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;public final &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;getAndIncrement&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{  
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(;;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{  
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; current &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;();  
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; next &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; current &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;  
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;compareAndSet&lt;&#x2F;span&gt;&lt;span&gt;(current, next))  
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; current;  
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}  
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}  
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;public final &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;boolean &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;compareAndSet&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; expect, &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; update) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{  
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; unsafe&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;compareAndSwapInt&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;, valueOffset, expect, update);  
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因而在大部分情况下，java中使用Atomic包中的incrementAndGet的性能比用synchronized高出几倍。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;si-abawen-ti&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#si-abawen-ti&quot; aria-label=&quot;Anchor link for: si-abawen-ti&quot;&gt;四、ABA问题&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;thread1意图对val=1进行操作变成2，cas(val,1,2)。
thread1先读取val=1；thread1被抢占（preempted），让thread2运行。
thread2 修改val=3，又修改回1。
thread1继续执行，发现期望值与“原值”（其实被修改过了）相同，完成CAS操作。
使用CAS会造成ABA问题，特别是在使用指针操作一些并发数据结构时。
解决方案
ABAʹ：添加额外的标记用来指示是否被修改。
从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;casyin-fa-de-liang-ge-wen-ti&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#casyin-fa-de-liang-ge-wen-ti&quot; aria-label=&quot;Anchor link for: casyin-fa-de-liang-ge-wen-ti&quot;&gt;CAS引发的两个问题&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。&lt;&#x2F;p&gt;
&lt;p&gt;在JVM中的CAS操作就是基于处理器的CMPXCHG汇编指令实现的，因此，JVM中的CAS的原子性是处理器保障的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;abawen-ti&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#abawen-ti&quot; aria-label=&quot;Anchor link for: abawen-ti&quot;&gt;ABA问题&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。ABA问题的解决思路是，每次变量更新的时候把变量的版本号加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;caszi-xuan-dao-zhi-de-kai-xiao&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#caszi-xuan-dao-zhi-de-kai-xiao&quot; aria-label=&quot;Anchor link for: caszi-xuan-dao-zhi-de-kai-xiao&quot;&gt;CAS自旋导致的开销&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。&lt;&#x2F;p&gt;
&lt;p&gt;解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。JDK8新增的LongAddr,和ConcurrentHashMap类似的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。&lt;&#x2F;p&gt;
</content>
    </entry>
    <entry xml:lang="en">
        <title>lock-free circular array queue[翻译]</title>
        <published>2021-02-05T17:26:18+00:00</published>
        <updated>2021-02-05T17:26:18+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://wendajiang.github.io/yet-another-implement-of-lock-free-circular-array-queue/" type="text/html"/>
        <id>https://wendajiang.github.io/yet-another-implement-of-lock-free-circular-array-queue/</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.codeproject.com&#x2F;Articles&#x2F;153898&#x2F;Yet-another-implementation-of-a-lock-free-circul&quot;&gt;原链接&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;推荐：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~410-s05&#x2F;lectures&#x2F;L31_LockFree.pdf&quot;&gt;Lock-free Programming&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;preshing.com&#x2F;20120612&#x2F;an-introduction-to-lock-free-programming&#x2F;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;1-introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-introduction&quot; aria-label=&quot;Anchor link for: 1-introduction&quot;&gt;1. Introduction&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;毫无疑问，当今提升应用的性能的一个方式就是：&lt;strong&gt;并发&lt;&#x2F;strong&gt;。Thread 已经存在很长时间了，过去，大多数计算机只有一个处理器核心时，线程主要用于将总任务分解为小的执行单元，从而使一些执行单元等待资源的时候，可以执行其他执行单元。一个简单的例子是，监听TCP端口的网络应用，请求到达该端口之后会进行一些处理。在单线程方式下，应用直到处理完这个请求不能响应更多的请求，因此可能用户会认为这个应用宕机了。多线程时，可以由新线程处理请求，主线程一直监听请求。&lt;&#x2F;p&gt;
&lt;p&gt;单处理器计算机上，使用多线程的应用程序可能不会达到预期的结果。为了使处理器工作，多个线程可能互相影响，比如多个线程的通信的开销和共享数据，最终甚至不如单线程应用的性能好。&lt;&#x2F;p&gt;
&lt;p&gt;在SMP(symmetric multiprocessing)上，多线程应用可以同时（译者注：物理上的同时）work。每个线程使用一个物理处理器核心。在 N-处理器机器上运行 N-thread 程序理论上可以节省 N 倍的运行时间（当然实际上由于通信开销和共享数据开销，没有达到理论值）&lt;&#x2F;p&gt;
&lt;p&gt;SMP机器在过去很昂贵，只有极力推崇这种软件（译者注：大公司？）才能负担起费用，但是当今时代，多核处理器越来越便宜，所以将应用并发获得更高的性能越来越流行。&lt;&#x2F;p&gt;
&lt;p&gt;但是并发开发不是简单的工作。线程必须共享数据并互相通信，你会发现你面对的都是相同的老问题：&lt;strong&gt;死锁，共享数据失控，跨线程动态内存分配&#x2F;销毁等&lt;&#x2F;strong&gt;。此外，如果你有幸在开发具有高性能（并发）的应用，你还会发现一系列不同的问题，有些会严重影响性能：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;yet-another-implement-of-lock-free-circular-array-queue&#x2F;#no1&quot;&gt;Cache Trashing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;yet-another-implement-of-lock-free-circular-array-queue&#x2F;#no2&quot;&gt;Contention on your synchonization mechanism. Queues&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;yet-another-implement-of-lock-free-circular-array-queue&#x2F;#no3&quot;&gt;Dynamic memory allocation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;本文就提出了通过使用 array based lock-free queue 来最小化上面三个问题对性能的影响。尤其是动态内存分配的使用，因为这是设计无锁队列时的主要目标&lt;&#x2F;p&gt;
&lt;h2 id=&quot;2-how-synchronizing-threads-can-reduce-the-overall-performance&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-how-synchronizing-threads-can-reduce-the-overall-performance&quot; aria-label=&quot;Anchor link for: 2-how-synchronizing-threads-can-reduce-the-overall-performance&quot;&gt;2. How synchronizing threads can reduce the overall performance&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;a name=&quot;no1&quot;&gt;
&lt;h3 id=&quot;2-1-cache-trashing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-1-cache-trashing&quot; aria-label=&quot;Anchor link for: 2-1-cache-trashing&quot;&gt;2.1 Cache trashing&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Threads are (from Wikipedia): &amp;quot;the smallest unit of processing that can be scheduled by an operating system&amp;quot;.每个系统有自己的线程实现，但是基本是一个进程内的指令集合加上一些进程内的local内存。线程执行一些指令，但是共享进程的内存空间。在Linux中（本文中写的queue优先在这个系统上执行），一个线程就是“执行的上下文（context of execution）”，没有线程概念。Linux 将线程实现为标准进程。Linux 内核没有提供任何关于线程特殊的调度语义或者数据结构。线程仅仅是与其他进程共享某些资源的进程。&lt;&#x2F;p&gt;
&lt;p&gt;每个执行的任务，线程，执行上下文，随你怎么称呼它【译者注：任务，线程，执行上下文在本文中同义】，使用一系列 CPU 的寄存器去运行。它们包含了任务的内部数据，比如正在执行的指令地址，操作或者操作结果，栈的指针等。这些信息就叫做“context（上下文）”。任何抢占式系统（大多数现代系统是抢占式的）都必须能够在几乎任何地方停止正在运行的任务，将上下文保存在某个地方，以便将来还原时使用（少数例外系统，比如进程声明自己一段时间使用CPU）。任务恢复后，就从停止的地方继续执行，就像没有什么发生一样。处理器是多任务共享的，所以等待 IO 的任务就可以被其它任务抢占。单处理系统上表现的想多处理器一样，但是就像生活的所有事情一样，存在 trade-off：处理器共享，但是每次任务被抢占，都会存在上下文保存和恢复的开销。&lt;&#x2F;p&gt;
&lt;p&gt;在save&#x2F;restore context 过程中，存在隐藏开销：存在 &lt;strong&gt;cache&lt;&#x2F;strong&gt;中的数据是之前任务的，对于新任务无用。考虑到&lt;strong&gt;处理器比内存处理速度快几倍&lt;&#x2F;strong&gt;，所以大量的时间浪费在等待从内存读写数据到处理器。这也是 cache 在处理器和标准 RAM memory 之间的原因。Cache 很小但是很快，用于保存在不久将来会被访问的从 RAM memory 复制的数据。在处理密集型程序中，缓存miss对于性能影响非常大，如果没有缓存miss，性能将会有几倍的提升。&lt;&#x2F;p&gt;
&lt;p&gt;所以每次任务被强占 cache 都会被重写，这意味着对于 CPU 来说恢复运行要等一段时间。（有些操作系统，比如 Linux 会试图在最后一个正在执行任务的处理器上还原进程，但是取决于最后一个进程需要的内存大小，cache仍然可能会失效【译者注：这里没看懂。。。】）。当然我不是说抢占是坏事，抢占对于系统正确运行是必要的，但是可能由于你的设计，有些线程过于频繁的被抢占，会由于 cache 垃圾大大降低性能&lt;&#x2F;p&gt;
&lt;p&gt;什么时候任务会被抢占？取决于你的系统，但是中断处理，timers和系统调用很可能导致操作系统抢占子系统从而导致系统为其他进程分配处理时间。这是操作系统的难题一部分，因为没有人想要进程“饥饿”太长时间。某些系统调用处理“阻塞”状态，这意味着任务向操作系统请求资源继续执行。这是抢占式任务的很合适的例子，因为在资源准备好之前没有事情做，所以操作系统会挂起这个任务并执行其他任务。&lt;&#x2F;p&gt;
&lt;p&gt;资源通常表示内存，硬盘，外围设备或者网络中的数据，阻塞的同步机制比如信号量或者互斥量。如果任务试图获取已经被持有的互斥量，就会被抢占，一旦互斥量被释放，线程就会被加入到“ready-to-run”的任务队列中。所以如果你担心任务被频繁抢占，应该尽可能避免使用阻塞同步机制。&lt;&#x2F;p&gt;
&lt;p&gt;但是就像生活一样，没有事情是简单的。如果在避免使用阻塞同步机制的同时，使用的线程数量远多于物理处理器核心数，则可能会导致系统延迟。操作系统轮换任务的次数越少，任务等待执行的时间越长。甚至可能在应用整个生命周期内都一直等待空余出来的处理器。没有标准，依赖于你的应用和系统。比如，在处理密集的实时应用中，我会选择非阻塞机制同步线程，然后执行比物理核心更少的线程数，尽管这并不是万能药。在一些其他应用中，有大量等待数据的场景，比如网络，非阻塞同步会危害系统。没有不老之泉，每个方案都有其优势和局限，完全由你来决定如何选择。&lt;&#x2F;p&gt;
&lt;a name=&quot;no2&quot;&gt;
&lt;h3 id=&quot;2-2-contentin-on-your-synchonization-mechanism-queues&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-2-contentin-on-your-synchonization-mechanism-queues&quot; aria-label=&quot;Anchor link for: 2-2-contentin-on-your-synchonization-mechanism-queues&quot;&gt;2.2 Contentin on your synchonization mechanism. Queues&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;queue可以轻松应用于各种多线程场景。如果多线程需要通信，第一个浮现在我脑海的就是 queue。易于理解，易于使用，方便测试，还易于传授【译者：:)】世界上的每个开发都应该会queue，它无处不在。&lt;&#x2F;p&gt;
&lt;p&gt;queue 易于在单线程程序中使用，并且可以简单地适配到多线程系统。你需要的就是一个没有保护的队列（比如 C++中的 &lt;code&gt;std::queue&lt;&#x2F;code&gt;）和阻塞的同步机制（比如 mutex 和 conditional variables）。我上传了一个简单的使用glib的阻塞队列实现，不过由于 GAysncQueue是已经包含在 glib 中的线程安全队列实现，所以并不需要这样一个重复造的轮子，但是这份代码是一个将标准队列转换为线程安全队列的绝佳例子。&lt;&#x2F;p&gt;
&lt;p&gt;让我们来看下大多数 queue 中公共方法(IsEmpty, Push, Pop)的实现。基本无保护的 queue 是 &lt;code&gt;std::queue&lt;&#x2F;code&gt;声明为 &lt;code&gt;std::queue&amp;lt;t&amp;gt; m_theQueue&lt;&#x2F;code&gt;。三个非线程安全的方法实现使用 glib 的互斥量和条件变量（声明为&lt;code&gt;GMutex* m_mutex Cond* m_cond&lt;&#x2F;code&gt;）。从本文可以下载代码，还包含了&lt;code&gt;TryPush,TryPop&lt;&#x2F;code&gt;的方法实现，这两个方法当 queue 满或者空时不会阻塞。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;BlockingQueue&amp;lt;T&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;IsEmpty&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; rv;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_mutex_lock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_mutex&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  rv &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;empty&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_mutex_unlock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_mutex&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; rv;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;IsEmpty&lt;&#x2F;code&gt;当queue没有元素时返回&lt;code&gt;true&lt;&#x2F;code&gt;，但是必须对这个原始队列加上保护，这意味着要使用这个队列的线程必须等待 mutex 被释放后才能使用。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;BlockingQueue&amp;lt;T&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;Push&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_elem&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_mutex_lock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_mutex&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_maximumSize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_cond_wait&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_cond&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_mutex&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; queueEmpty &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;empty&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(a_elem);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(queueEmpty)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; wake up threads waiting for stuff
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_cond_broadcast&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_cond&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_mutex_unlock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_mutex&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Push&lt;&#x2F;code&gt;往队列里插入元素。如果其他线程正在操作队列，这个线程会阻塞。如果队列已满，线程会阻塞，直到其他线程执行&lt;code&gt;Pop&lt;&#x2F;code&gt;操作，当然调用线程在等待其他线程弹出元素时不会占用任何 CPU 时间，因为操作系统已将其置为睡眠状态。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;BlockingQueue&amp;lt;T&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;Pop&lt;&#x2F;span&gt;&lt;span&gt;(T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;out_data&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_mutex_lock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_mutex&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;empty&lt;&#x2F;span&gt;&lt;span&gt;()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_cond_wait&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_cond&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_mutex&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; queueFull &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_maximumSize&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;? &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;true &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;  out_data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;front&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(queueFull) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; wake up threads waiting for stuff
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_cond_broadcase&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_cond&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_mutex_unlock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_mutex&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Pop&lt;&#x2F;code&gt;从对列中弹出一个元素（并删除它）。要使用的线程会阻塞如果另一个线程正在使用该队列。如果队列是空的，线程会阻塞，直到有其他队列往队列里加入元素，当然在等待其他线程插入元素时不会占用 CPU 时间，因为已被置为睡眠状态。&lt;&#x2F;p&gt;
&lt;p&gt;正如我在上一节解释的一样，&lt;strong&gt;阻塞不是一件平凡操作&lt;&#x2F;strong&gt;。它涉及操作系统将当前任务“挂起”，或者睡眠（不使用CPU等待）。一旦资源（比如mutex）可用，阻塞的任务就会被唤醒，同样不是平凡操作。**在负载很重的应用中使用这种阻塞队列在线程间传递消息就引起竞争，**意味着，&lt;strong&gt;将会花费大量时间（sleeping, waiting, awakenging）在试图访问queue，而不是执行真正的任务&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在最简单的场景中，一个生产者线程往队列插入数据，一个消费者线程消费数据，两个线程都在竞争线程安全队列的互斥量。如果我们自己来实现而不是包装现成的队列，就可以使用两个不同的互斥量，一个用来插入数据，一个用来弹出数据。这种实现里面，竞争只会发生在边界情况，就是队列满或者空之时。现在，一旦需要超过一个生产者线程或者消费者线程，问题就又回来了。&lt;&#x2F;p&gt;
&lt;p&gt;这就是应用无阻塞机制的地方。&lt;strong&gt;Tasks don&#x27;t &amp;quot;fight&amp;quot; for any resource, they &amp;quot;reserve&amp;quot; a place in the queue without being blocked or unblocked, and then they insert&#x2F;remove data from the queue&lt;&#x2F;strong&gt;【译者注：这里不翻译】。这个机制需要一个特殊操作：CAS（Compare And Swap），维基百科中的定义：a special instruction that atomically compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value，举例如下&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;volatile &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; a;
&lt;&#x2F;span&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; this will loop while &amp;#39;a&amp;#39; is not equal to 1. If it is equal to 1 the operation will atomically
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; set a to 2 and return true
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;a, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)) ;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;使用 CAS 实现lock-free 并不是新话题，有很多数据结构的示例，大部分使用链表举例。可以看看文献中2，3，&lt;a href=&quot;https:&#x2F;&#x2F;www.drdobbs.com&#x2F;parallel&#x2F;writing-lock-free-code-a-corrected-queue&#x2F;210604448&quot;&gt;4&lt;&#x2F;a&gt;【译者注: 2,3 连接找不到了】，这里目的不是描述什么  lock-free queue，而是：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;insert 新数据到新节点（malloc出来），然后使用CAS操作放到队列上&lt;&#x2F;li&gt;
&lt;li&gt;从队列 remove 数据，使用 CAS 从链表上将节点删除&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这是链表 lock-free queue 的简单实现，从 2【译者注：反正找不到这个原文】 中复制，基于 &lt;a href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;248052.248106&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typedef struct&lt;&#x2F;span&gt;&lt;span&gt; _Node Node;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typedef struct&lt;&#x2F;span&gt;&lt;span&gt; _Queue Queue;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;_Node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;data;
&lt;&#x2F;span&gt;&lt;span&gt;    Node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;next;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;_Queue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;head;
&lt;&#x2F;span&gt;&lt;span&gt;    Node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;tail;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Queue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;queue_new&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Queue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;q &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_slice_new&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;sizeof&lt;&#x2F;span&gt;&lt;span&gt;(Queue));
&lt;&#x2F;span&gt;&lt;span&gt;    q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;head &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;tail &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_slice_new0&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;sizeof&lt;&#x2F;span&gt;&lt;span&gt;(Node));
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; q;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;void
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;queue_enqueue&lt;&#x2F;span&gt;&lt;span&gt;(Queue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;q&lt;&#x2F;span&gt;&lt;span&gt;, gpointer &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;node, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;tail, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;next;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_slice_new&lt;&#x2F;span&gt;&lt;span&gt;(Node);
&lt;&#x2F;span&gt;&lt;span&gt;    node&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; data;
&lt;&#x2F;span&gt;&lt;span&gt;    node&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;next &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;TRUE&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        tail &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;tail&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        next &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; tail&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(tail &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;!=&lt;&#x2F;span&gt;&lt;span&gt; q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;tail&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(next &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;tail&lt;&#x2F;span&gt;&lt;span&gt;, tail, next);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;tail&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;, null, node)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#ff79c6;color:#f8f8f0;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;tail&lt;&#x2F;span&gt;&lt;span&gt;, tail, node);
&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#ff79c6;color:#f8f8f0;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;gpointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;queue_dequeue&lt;&#x2F;span&gt;&lt;span&gt;(Queue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;q)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;node, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;tail, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;next;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;TRUE&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        head &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        tail &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;tail&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        next &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; head&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(head &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;!=&lt;&#x2F;span&gt;&lt;span&gt; q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(next &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; Empty
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(head &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; tail) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;tail&lt;&#x2F;span&gt;&lt;span&gt;, tail, next);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;        data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span&gt;, head, next))
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;g_slice_free&lt;&#x2F;span&gt;&lt;span&gt;(Node, head); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; This isn&amp;#39;t safe
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; data;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在没有 GC 的语言中（C++就是其中之一），由于所谓的 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ABA_problem&quot;&gt;ABA 问题&lt;&#x2F;a&gt; ，对&lt;code&gt;g_slice_free&lt;&#x2F;code&gt;的调用是不安全的：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Thread T1 reads a value to dequeue and stops just before the first call to CAS in &lt;code&gt;queue_dequeue&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Thread T1 is preemtped. T2 attempts a &lt;code&gt;CAS&lt;&#x2F;code&gt; operation to remove the same node T1 was about to dequeue&lt;&#x2F;li&gt;
&lt;li&gt;It succedes and frees the memory allocated for that node&lt;&#x2F;li&gt;
&lt;li&gt;That same thread (or a new one, for instace T3) is going to enqueue a new node. the call to malloc returns the same address that was being used by the node removed in step 2-3. It adds that node into the queue&lt;&#x2F;li&gt;
&lt;li&gt;T1 takes the processor again, the &lt;code&gt;CAS&lt;&#x2F;code&gt; operation succeds incorrectly since the address is the same, but it&#x27;s not the same node. T1 removes the wrong node&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;ABA 问题可以对每个节点加上引用计数解决。在假定CAS操作正确之前必须检查引用计数以避免 ABA 问题。不过好消息是，本文提到的 queue 不会受 ABA 问题影响，因为不使用动态内存分配。&lt;&#x2F;p&gt;
&lt;a name=&quot;no3&quot;&gt;
&lt;h3 id=&quot;2-3-dynamic-memory-allocation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-3-dynamic-memory-allocation&quot; aria-label=&quot;Anchor link for: 2-3-dynamic-memory-allocation&quot;&gt;2.3 Dynamic memory allocation&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;在多线程系统中，必须慎重考虑内存分配。&lt;strong&gt;标准内存分配机制在为一个任务在堆上分配内存时会阻塞所有共享内存空间的任务&lt;&#x2F;strong&gt;（进程内的所有线程）。这种方式简单正确，不会出现两个线程分配相同的地址，因为不会同时分配内存。但是当存在很多内存分配操作时就会导致性能很差（&lt;strong&gt;必须提到的是类似标准库中 queue 或者 map 的插入操作就会在堆上分配内存&lt;&#x2F;strong&gt;）&lt;&#x2F;p&gt;
&lt;p&gt;有一些库可以覆盖标准分配机制，提供无锁的内存分配机制来减少堆的争用，比如，&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pld-linux&#x2F;libhoard&quot;&gt;libhoard&lt;&#x2F;a&gt;。有许多不同的类型的库，但是当你使用它们覆盖标准库操作时可能会对你的系统产生巨大的影响，因为你可能需要修改你的同步机制来适配无锁的内存分配机制。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;3-the-circular-array-based-lock-free-queue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-the-circular-array-based-lock-free-queue&quot; aria-label=&quot;Anchor link for: 3-the-circular-array-based-lock-free-queue&quot;&gt;3. The circular array based lock-free queue&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;在此基于 array 的 lock-free 的环形队列首次登场，尽可能降低第2节三个问题的影响。可以总结为以下特性：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;作为lock-free同步机制，降低了任务被强占的频率，从而降低了 cache trashing&lt;&#x2F;li&gt;
&lt;li&gt;同样的作为 lock-free 队列，线程之间竞争减少，因为lock-free：线程基本上是先声明空间已被占用，然后将数据填入&lt;&#x2F;li&gt;
&lt;li&gt;不需要在堆上分配空间&lt;&#x2F;li&gt;
&lt;li&gt;不会受到 ABA 问题的影响，当然也加入了 array 一些操作的开销&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;3-1-how-does-it-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-1-how-does-it-work&quot; aria-label=&quot;Anchor link for: 3-1-how-does-it-work&quot;&gt;3.1 How does it work?&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;queue 基于 array 和三个 index：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;writeIndex&lt;&#x2F;code&gt;:新元素要被插入的地方&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;readIndex&lt;&#x2F;code&gt;:下一个被弹出的元素位置&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;maximumReadIndex&lt;&#x2F;code&gt;:上一个已经‘commit’要插入的元素位置。如果与&lt;code&gt;writeIndex&lt;&#x2F;code&gt;位置不同，意味着有写入被挂起，也意味着这个位置已经被声明占用了，但是数据还没有写进去到队列里，所以试图读的线程需要等待数据被填入&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;值得一提的是，三个index是必要的，因为队列允许多生产者和多消费者。有&lt;a href=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;translate&#x2F;queue&#x2F;lock-free&#x2F;2021&#x2F;02&#x2F;07&#x2F;single-p-single-c-lock-free-cricular-queue.html&quot;&gt;文章&lt;&#x2F;a&gt;研究了单生产者单消费者，这篇文章值得一读（我一直很喜欢 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;KISS_principle&quot;&gt;KISS 原则&lt;&#x2F;a&gt;）。这里的事情变得复杂很多，因为队列必须对于各种线程配置都要线程安全。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;3-1-1-the-cas-operation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-1-1-the-cas-operation&quot; aria-label=&quot;Anchor link for: 3-1-1-the-cas-operation&quot;&gt;3.1.1 The CAS operation&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;Lock-free queue 同步机制基于 CAS 的 CPU 指令。CAS 操作已经在 GCC 4.1.0 实现。因此在GCC4.4 版本编译，我采用了 GCC 的 &lt;code&gt;build_in operation: __sync_bool_compare_and_swap&lt;&#x2F;code&gt;（&lt;a href=&quot;https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.4.2&#x2F;gcc&#x2F;Atomic-Builtins.html&quot;&gt;这里是GCC文档&lt;&#x2F;a&gt;），为了移植性考虑，这个操作通过宏定义了 &lt;code&gt;CAS&lt;&#x2F;code&gt;，在&lt;code&gt;atomic_ops.h&lt;&#x2F;code&gt;文件中：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_ptr&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_oldVal&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_newVal&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;__sync_bool_compare_and_swap&lt;&#x2F;span&gt;&lt;span&gt;(a_ptr, a_oldVar, a_newVal)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果要使用其他编译器或者其他版本，你需要宏定义CAS操作，接口满足如下条件：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;第一个是可变的地址参数&lt;&#x2F;li&gt;
&lt;li&gt;第二个参数是老值&lt;&#x2F;li&gt;
&lt;li&gt;第三个参数是新值&lt;&#x2F;li&gt;
&lt;li&gt;成功返回&lt;code&gt;true&lt;&#x2F;code&gt;，否则返回&lt;code&gt;false&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;a name=&quot;no5&quot;&gt;
&lt;h4 id=&quot;3-1-2-inserting-elements-into-the-queue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-1-2-inserting-elements-into-the-queue&quot; aria-label=&quot;Anchor link for: 3-1-2-inserting-elements-into-the-queue&quot;&gt;3.1.2 Inserting elements into the queue&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;这是插入元素的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;* ... *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; ELEM_T, &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; Q_SIZE&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;inline
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t &lt;&#x2F;span&gt;&lt;span&gt;ArrayLockFreeQueue&amp;lt;ELEM_T, Q_SIZE&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_count&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(a_count &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span&gt; Q_SIZE);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;* ... *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; ELEM_T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;ArrayLockFreeQueue&amp;lt;ELEM_T&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; ELEM_T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_data&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentReadIndex;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentWriteIndex;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_writeIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        currentReadIndex  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_readIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;==
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentReadIndex))
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; the queue is full
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_writeIndex&lt;&#x2F;span&gt;&lt;span&gt;, currentWriteIndex, (currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; We know now that this index is reserved for us. Use it to save the data
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentWriteIndex)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a_data;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; update the maximum read index after saving the data. It wouldn&amp;#39;t fail if there is only one thread
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; inserting in the queue. It might fail if there are more than 1 producer threads because this
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; operation has to be done in the same order as the previous CAS
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_maximumReadIndex&lt;&#x2F;span&gt;&lt;span&gt;, currentWriteIndex, (currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; this is a good place to yield the thread in case there are more
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; software threads than hardware processors and you have more
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; than 1 producer thread
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; have a look at sched_yield (POSIX.1b)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;sched_yield&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;下图描述了一个queue的初始状态，每个格子表示queue的位置，如果标记了 X 表示包含了数据，空白格子就是空的。图中表示当前queue已经插入了两个元素。&lt;code&gt;writeIndex&lt;&#x2F;code&gt;指向新元素将要插入的位置，&lt;code&gt;readIndex&lt;&#x2F;code&gt;指向下次&lt;code&gt;pop&lt;&#x2F;code&gt;弹出的元素位置&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205150248827.png&quot; alt=&quot;image-20210205150248827&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;基本上，当新元素被&lt;code&gt;push&lt;&#x2F;code&gt;操作写入队列时，writeIndex increment。MaximumReadIndex指向最新的有效数据&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205150433877.png&quot; alt=&quot;image-20210205150433877&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一旦新空间被占用，当前线程就会开始将数据拷贝进queue。然后increment maximumReadIndex&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205150546567.png&quot; alt=&quot;image-20210205150546567&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;此时，队列中有了三个被插入的元素。下一步，另一个任务试图继续插入新元素&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205150728199.png&quot; alt=&quot;image-20210205150728199&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;已经腾出了数据的空间，但是这时被其它线程抢占也要插入一个元素（再占用一个）&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205150852717.png&quot; alt=&quot;image-20210205150852717&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;此时，线程开始往占用的位置拷贝数据，但是&lt;strong&gt;必须&lt;&#x2F;strong&gt;按照&lt;strong&gt;严格的顺序&lt;&#x2F;strong&gt;：第一个生产者线程 increment maximumReadIndex，然后第二个线程再 increment。这个顺序很重要，因为在允许消费线程将其从队列中&lt;code&gt;pop&lt;&#x2F;code&gt;之前，要确保数据被保存到&#x27;commited&#x27;的位置。【译者注：这个顺序通过CAS对于maximumReadIndex保证】&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205151841109.png&quot; alt=&quot;image-20210205151841109&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;第一个生产者【译者注：1，2的先后顺序由reversed位置定义】将数据提交位置。现在该第二个线程继续自己的任务了&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205151944816.png&quot; alt=&quot;image-20210205151944816&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;现在队列插入了5个元素&lt;&#x2F;p&gt;
&lt;h4 id=&quot;3-1-3-removing-elements-from-the-queue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-1-3-removing-elements-from-the-queue&quot; aria-label=&quot;Anchor link for: 3-1-3-removing-elements-from-the-queue&quot;&gt;3.1.3 Removing elements from the queue&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;这是&lt;code&gt;pop&lt;&#x2F;code&gt;的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;* ... *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; ELEM_T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;ArrayLockFreeQueue&amp;lt;ELEM_T&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;(ELEM_T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_data&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentMaximumReadIndex;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentReadIndex;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; to ensure thread-safety when there is more than 1 producer thread
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; a second index is defined (m_maximumReadIndex)
&lt;&#x2F;span&gt;&lt;span&gt;        currentReadIndex        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_readIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        currentMaximumReadIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_maximumReadIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentReadIndex) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;==
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentMaximumReadIndex))
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; the queue is empty or
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; a producer thread has allocate space in the queue but is
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; waiting to commit the data into it
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; retrieve the data from the queue
&lt;&#x2F;span&gt;&lt;span&gt;        a_data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentReadIndex)];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; try to perfrom now the CAS operation on the read index. If we succeed
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; a_data already contains what m_readIndex pointed to before we
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; increased it
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_readIndex&lt;&#x2F;span&gt;&lt;span&gt;, currentReadIndex, (currentReadIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; it failed retrieving the element off the queue. Someone else must
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; have read the element stored at countToIndex(currentReadIndex)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; before we could perform the CAS operation
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; keep looping to try again!
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; Something went wrong. it shouldn&amp;#39;t be possible to reach here
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8be9fd;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; Add this return statement to avoid compiler warnings
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还是用插入数据一节的queue的初始状态。有两个元素已经插入队列。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205152150470.png&quot; alt=&quot;image-20210205152150470&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;消费线程，从&lt;code&gt;readIndex&lt;&#x2F;code&gt;复制数据，然后尝试在相同的&lt;code&gt;readIndex&lt;&#x2F;code&gt;执行&lt;code&gt;CAS&lt;&#x2F;code&gt;操作。如果线程执行&lt;code&gt;CAS&lt;&#x2F;code&gt;成功，表示数据已经从队列取出，因为&lt;code&gt;CAS&lt;&#x2F;code&gt;是原子的。如果&lt;code&gt;CAS&lt;&#x2F;code&gt;失败，下次尝试就会从新的位置重复这个过程，如下图&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205152645278.png&quot; alt=&quot;image-20210205152645278&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;结果就是下图&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;pics&#x2F;2021-02-05-yet-another-implement-of-lock-free-circular-array-queue&#x2F;image-20210205152726271.png&quot; alt=&quot;image-20210205152726271&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如果这个时候还有线程要读取数据，就会失败，因为队列已空。&lt;&#x2F;p&gt;
&lt;p&gt;现在一个任务尝试在队列中插入新元素，已经占到了位置但是提交数据被挂起，然后另一个线程想要&lt;code&gt;pop&lt;&#x2F;code&gt;一个元素，现在知道队列不空了，（因为&lt;code&gt;writeIndex != readIndex&lt;&#x2F;code&gt;），但是还不能读取，因为&lt;code&gt;maximumReadIndex != readIndex&lt;&#x2F;code&gt;。这个线程试图&lt;code&gt;pop&lt;&#x2F;code&gt;，将陷入循环中，直到数据被提交让&lt;code&gt;maximumReadIndex == readIndex&lt;&#x2F;code&gt;或者队列称为空（如果另有一个消费线程进来先消费了，然后再次&lt;code&gt;writeIndex == readIndex&lt;&#x2F;code&gt;）&lt;&#x2F;p&gt;
&lt;p&gt;【译者注：这里原文两个图不贴了，上面文字描述的更清楚】&lt;&#x2F;p&gt;
&lt;a name=&quot;no4&quot;&gt;
&lt;h4 id=&quot;3-1-4-on-the-need-for-yielding-the-processor-when-there-is-more-than-1-producer-thread&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-1-4-on-the-need-for-yielding-the-processor-when-there-is-more-than-1-producer-thread&quot; aria-label=&quot;Anchor link for: 3-1-4-on-the-need-for-yielding-the-processor-when-there-is-more-than-1-producer-thread&quot;&gt;3.1.4 On the need for yielding the processor when there is more than 1 producer thread&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;【译者注：本节详细阐述了push第二次 CAS 是为了保证 FIFO 顺序，这里如果单纯++，会导致数据错乱】&lt;&#x2F;p&gt;
&lt;p&gt;读者可能注意到了&lt;code&gt;push&lt;&#x2F;code&gt;函数中对于&lt;code&gt;sched_yield&lt;&#x2F;code&gt;的调用出让CPU，对于宣称 lock-free 的算法看起来有点奇怪。正如文章开头就提到的一样，多线程的性能下降原因之一就是&lt;strong&gt;cache trashing&lt;&#x2F;strong&gt;。典型造成&lt;code&gt;cache trashing&lt;&#x2F;code&gt;就是被强占的线程上下文需要操作系统从cache转移到主存，恢复时又要转移回来。&lt;&#x2F;p&gt;
&lt;p&gt;当算法调用&lt;code&gt;sched_yield&lt;&#x2F;code&gt;时，就是告诉操作系统：hi，你能把别的任务搞过来吗，我必须等会才能执行。lock-free 和 lock 同步机制的主要区别就是我们不需要阻塞，所以为啥要主动告诉操作系统赶紧抢占我？回答这个问题并不简单，涉及到了生产者将新数据保存到队列中，需要以FIFO 顺序执行两次 CAS 操作，一次申请分配空间，另一次通知消费者数据已经提交。&lt;&#x2F;p&gt;
&lt;p&gt;如果应用只有一个生产线程，&lt;code&gt;sched_yield&lt;&#x2F;code&gt;就不需要调用了，因为第二次 CAS 绝对不会失败。操作自然就会按照 FIFO 的顺序执行，因为只有一个线程在插入数据&lt;&#x2F;p&gt;
&lt;p&gt;当大于一个线程插入数据时，问题就来了。如同&lt;a href=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;yet-another-implement-of-lock-free-circular-array-queue&#x2F;#no5&quot;&gt;3.1.2节&lt;&#x2F;a&gt;表述那样插入数据，1CAS已经按照 FIFO 顺序申请空间后，2CAS必须也按照 FIFO 顺序执行。让我们考虑下面的场景，三个生产者一个消费者：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;线程1，2，3按照顺序申请空间。2CAS必须按照相同顺序执行，1，2，3&lt;&#x2F;li&gt;
&lt;li&gt;线程2先开始执行2CAS，但是因为Thread 1还没执行所以失败了，Thread 3也会失败&lt;&#x2F;li&gt;
&lt;li&gt;2和3线程陷入循环直到线程1执行了2CAS&lt;&#x2F;li&gt;
&lt;li&gt;线程1执行完之后，线程3必须等2执行&lt;&#x2F;li&gt;
&lt;li&gt;最终按序执行完&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;2CAS失败是可能spin也不失为一个好选择。当使用的多处理器机器的处理器数量大于线程数量时，这可能很好：线程卡住一直尝试在volatile variable(maximumReadIndex)上执行CAS操作，但是等待的线程可能分配到物理处理器核心，因此最终比如Thread1可能执行2CAS，自旋的操作也能结束。总而言之，该算法有保留线程循环的可能性，但是要保证这种行为是可行的，在某些特定情况可以删除&lt;code&gt;scheld_yield&lt;&#x2F;code&gt;。事实上，删除&lt;code&gt;scheld_yield&lt;&#x2F;code&gt;才是最好的性能。&lt;&#x2F;p&gt;
&lt;p&gt;但是&lt;code&gt;scheld_yield&lt;&#x2F;code&gt;对于多个生产者和线程数量大于物理核心数的场景是必要的。考虑之前的问题，当三个线程试图插入新数据到队列中，线程1在分配空间后被抢占，线程2，3会一直死循环直到线程1被唤醒，这就需要&lt;code&gt;sheld_yield&lt;&#x2F;code&gt;，操作系统不比一直让线程2，3保持循环，它们必须尽快阻塞，以让线程1执行2CAS，让自己能够继续执行。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;4-known-issues-of-the-queue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-known-issues-of-the-queue&quot; aria-label=&quot;Anchor link for: 4-known-issues-of-the-queue&quot;&gt;4. Known issues of the queue&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;这个lock-free 队列的主要目的是提供一个不需要动态内存分配的 lock-free 队列，已经搞定，但是算法存在一些已知的缺点，在生产环境中使用该算法应该考虑这些缺点是不是你关注的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-1-using-more-than-one-producer-thread&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-1-using-more-than-one-producer-thread&quot; aria-label=&quot;Anchor link for: 4-1-using-more-than-one-producer-thread&quot;&gt;4.1 Using more than one producer thread&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;如同在&lt;a href=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;yet-another-implement-of-lock-free-circular-array-queue&#x2F;#no4&quot;&gt;3.1.4&lt;&#x2F;a&gt;中描述一样（如果你要在多生产者环境中使用这个算法要仔细阅读这一节内容），如果有超过一个生产线程，由于必须按照 FIFO 顺序操作 &lt;code&gt;maximumReadIndex&lt;&#x2F;code&gt;，所以可能多次调用&lt;code&gt;sched_yield&lt;&#x2F;code&gt;导致花费很多开销。这个队列设计的原始场景只有一个生产线程，因此在多生产线程的场景，性能是肯定会下降的。&lt;&#x2F;p&gt;
&lt;p&gt;此外，如果你计划将此队列用于单生产者线程的场景，不需要第二个 CAS 操作。对于 &lt;code&gt;m_maximumReadIndex&lt;&#x2F;code&gt;的 CAS 可以被删除，所以代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; ELEM_T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;ArrayLockFreeQueue&amp;lt;ELEM_T&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; ELEM_T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_data&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentReadIndex;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentWriteIndex;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_writeIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    currentReadIndex  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_readIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;==
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentReadIndex))
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; the queue is full
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; save the date into the q
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentWriteIndex)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; a_data;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; No need to increment write index atomically. It is a 
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; requierement of this queue that only one thred can push stuff in
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_writeIndex&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; ELEM_T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;ArrayLockFreeQueue&amp;lt;ELEM_T&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;(ELEM_T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#ffb86c;&quot;&gt;a_data&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentMaximumReadIndex;
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentReadIndex;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; m_maximumReadIndex doesn&amp;#39;t exist when the queue is set up as
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; single-producer. The maximum read index is described by the current
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; write index
&lt;&#x2F;span&gt;&lt;span&gt;    currentReadIndex        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_readIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    currentMaximumReadIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_writeIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentReadIndex) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;==
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentMaximumReadIndex))
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; the queue is empty or
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; a producer thread has allocate space in the queue but is
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; waiting to commit the data into it
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; retrieve the data from the queue
&lt;&#x2F;span&gt;&lt;span&gt;    a_data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_theQueue&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;countToIndex&lt;&#x2F;span&gt;&lt;span&gt;(currentReadIndex)];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; try to perfrom now the CAS operation on the read index. If we succeed
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; a_data already contains what m_readIndex pointed to before we
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; increased it
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;CAS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_readIndex&lt;&#x2F;span&gt;&lt;span&gt;, currentReadIndex, (currentReadIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; it failed retrieving the element off the queue. Someone else must
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; have read the element stored at countToIndex(currentReadIndex)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; before we could perform the CAS operation
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; keep looping to try again!
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; Something went wrong. it shouldn&amp;#39;t be possible to reach here
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8be9fd;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6272a4;&quot;&gt;&#x2F;&#x2F; Add this return statement to avoid compiler warnings
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bd93f9;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果你要在单生产者，单消费者场景使用，再次推荐&lt;a href=&quot;https:&#x2F;&#x2F;wendajiang.github.io&#x2F;translate&#x2F;queue&#x2F;lock-free&#x2F;2021&#x2F;02&#x2F;07&#x2F;single-p-single-c-lock-free-cricular-queue.html&quot;&gt;此文章&lt;&#x2F;a&gt;，用了类似的环形队列设计。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-2-using-the-queue-with-smart-pointers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-2-using-the-queue-with-smart-pointers&quot; aria-label=&quot;Anchor link for: 4-2-using-the-queue-with-smart-pointers&quot;&gt;4.2 Using the queue with smart pointers&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;如果队列每个位置保存的是只能指针，请注意，插入队列的元素会由于智能指针的保护不能被完整删除，保存过元素的位置直到被新的智能指针占用才会完全删除这个数据，所以对于繁忙的队列这不是问题，不过开发者要注意的是，一旦队列第一次被占满，应用使用的内存就不会降下去了，即使队列已空【译者注：适配这个场景，要改代码，比如使用偏特化指定smart_pointer data_type要加入多余的处理？】&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-3-calculating-size-of-queue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-3-calculating-size-of-queue&quot; aria-label=&quot;Anchor link for: 4-3-calculating-size-of-queue&quot;&gt;4.3 Calculating size of queue&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;原始&lt;code&gt;size&lt;&#x2F;code&gt;可能会返回错的size数据&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#8be9fd;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; ELEM_T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;inline &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t &lt;&#x2F;span&gt;&lt;span&gt;ArrayLockFreeQueue&amp;lt;ELEM_T&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_writeIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#66d9ef;&quot;&gt;uint32_t&lt;&#x2F;span&gt;&lt;span&gt; currentReadIndex  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_readIndex&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; currentReadIndex)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt; currentReadIndex);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;m_totalSize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt; currentWriteIndex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff79c6;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt; currentReadIndex);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;下面的场景会返回错误size：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;uint32_t currentWriteIndex = m_writeIndex&lt;&#x2F;code&gt;被执行，&lt;code&gt;m_writeIndex&lt;&#x2F;code&gt;为3，&lt;code&gt;m_readIndex&lt;&#x2F;code&gt;为2，真实的size是1&lt;&#x2F;li&gt;
&lt;li&gt;这个线程被抢占，当此线程处于非活动状态时，队列中被插入，删除了两个元素，此时&lt;code&gt;m_writeIndex&lt;&#x2F;code&gt;为5，&lt;code&gt;m_readIndex&lt;&#x2F;code&gt;为4，size还是1&lt;&#x2F;li&gt;
&lt;li&gt;现在线程回来继续执行，&lt;code&gt;uint32_t currentReadIndex = m_readIndex&lt;&#x2F;code&gt;，读取到为4&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;currentReadIndex &amp;gt; currentWriteIndex&lt;&#x2F;code&gt;，所以返回&lt;code&gt;m_totalSize + currentWriteIndex - currentReadIndex&lt;&#x2F;code&gt;，也就是说当队列几乎为空的时候，返回队列几乎已满&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;本文上传的代码已经解决了这个问题，加入了一个新的类数据成员，表示当前队列的数据个数，也是用原子操作进行操作。这个方案引入了很大的开销，因为不能被编译器优化，所以原子操作是昂贵的。&lt;&#x2F;p&gt;
&lt;p&gt;这也是为什么留给开发者选择是否激活这个size变量的原因，取决于应用对于需求的要求，这个&lt;code&gt;size&lt;&#x2F;code&gt;操作是不是必要的，来决定是不是要引入这个开销。编译器会预处理&lt;code&gt;array_lock_free_queue.h&lt;&#x2F;code&gt;调用&lt;code&gt;ARRAY_LOCK_FREE_Q_KEEP_REAL_SIZE&lt;&#x2F;code&gt;定义，来决定size开销是否会激活。如果没有定义就不会激活这个开销，但是函数可能会返回错误size&lt;&#x2F;p&gt;
&lt;h2 id=&quot;5-compiling-the-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#5-compiling-the-code&quot; aria-label=&quot;Anchor link for: 5-compiling-the-code&quot;&gt;5. Compiling the code&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;【译者注：本节简单意译】&lt;&#x2F;p&gt;
&lt;p&gt;这里的代码都是模板代码，所以只需要头文件，不过提供了对应测试代码，是&lt;code&gt;cpp&lt;&#x2F;code&gt;格式。测试代码中使用了 &lt;code&gt;comp&lt;&#x2F;code&gt;，跨平台内存共享并行编程OpenMP 接口的 GNU c&#x2F;c++实现已经包含在了 GCC4.2 中。OpenMP 是跨平台开发并发程序一个简单灵活的接口。&lt;&#x2F;p&gt;
&lt;p&gt;所以代码分为了三个部分：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;array based lock-free queue:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;有两个版本的代码，分别在 array_lock_free_queue.h 和 array_lock_free_queue_single_producer.h 中，单生产者版本为场景优化过&lt;&#x2F;li&gt;
&lt;li&gt;注意，代码没有在64位环境中测试过&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Glib based blocking queue: &lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;首先你的系统中需要有Glib，Linux系统一般已经包含&lt;&#x2F;li&gt;
&lt;li&gt;使用了glib的 mutex 和 cond variable ，所以编译时要连接上&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;测试程序：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上面两个部分&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;GNU make 程序&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#282a36;color:#f8f8f2;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#50fa7b;&quot;&gt;make&lt;&#x2F;span&gt;&lt;span&gt; N_PRODUCERS=1 N_CONSUMERS=1 N_ITERATIONS=10000000 QUEUE_SIZE=1000
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;N_PRODUCERS 是生产线程的数量&lt;&#x2F;li&gt;
&lt;li&gt;N_CONSUMERS 是消费线程的数量&lt;&#x2F;li&gt;
&lt;li&gt;N_ITERATIONS 是将要插入和弹出元素之和&lt;&#x2F;li&gt;
&lt;li&gt;QUEUE_SIZE 是队列的最大长度&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;GCC版本大于 4.2&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;需要加上&lt;code&gt;OMP_NESTED=TRUE&lt;&#x2F;code&gt;前缀，例如&lt;code&gt;OMP_NESTED=TRUE .&#x2F;test_lock_free_q&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;6-a-few-figures&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-a-few-figures&quot; aria-label=&quot;Anchor link for: 6-a-few-figures&quot;&gt;6. A few figures&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;【译者注：本大节全是测试图例，不搬运，感兴趣请在原链接看，或者自己运行代码得到直观对比】&lt;&#x2F;p&gt;
&lt;h3 id=&quot;6-1-the-impact-on-performance-of-the-2nd-cas-operation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-1-the-impact-on-performance-of-the-2nd-cas-operation&quot; aria-label=&quot;Anchor link for: 6-1-the-impact-on-performance-of-the-2nd-cas-operation&quot;&gt;6.1 The impact on performance of the 2nd CAS operation&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;6-2-lock-free-vs-blocking-queue-number-of-threads&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-2-lock-free-vs-blocking-queue-number-of-threads&quot; aria-label=&quot;Anchor link for: 6-2-lock-free-vs-blocking-queue-number-of-threads&quot;&gt;6.2 Lock-free vs. blocking queue. Number of Threads&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;6-3-performance-using-4-threads&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-3-performance-using-4-threads&quot; aria-label=&quot;Anchor link for: 6-3-performance-using-4-threads&quot;&gt;6.3 Performance using 4 threads&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;6-3-1-one-producer-thread&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-3-1-one-producer-thread&quot; aria-label=&quot;Anchor link for: 6-3-1-one-producer-thread&quot;&gt;6.3.1 One producer thread&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;h4 id=&quot;6-3-2-two-producer-threads&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-3-2-two-producer-threads&quot; aria-label=&quot;Anchor link for: 6-3-2-two-producer-threads&quot;&gt;6.3.2 Two producer threads&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;h4 id=&quot;6-3-3-three-producer-threads&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-3-3-three-producer-threads&quot; aria-label=&quot;Anchor link for: 6-3-3-three-producer-threads&quot;&gt;6.3.3 Three producer threads&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;
&lt;h3 id=&quot;6-4-a-4-core-machine&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-4-a-4-core-machine&quot; aria-label=&quot;Anchor link for: 6-4-a-4-core-machine&quot;&gt;6.4 A 4-core machine&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;h2 id=&quot;7-conclusions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#7-conclusions&quot; aria-label=&quot;Anchor link for: 7-conclusions&quot;&gt;7. Conclusions&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;基于 lock-free 队列的 array 已经被证明了两个版本都是线程安全的，其中一个版本支持多生产者，另一个支持多消费者。队列用在多线程应用作为同步机制是安全的，因为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;CAS 操作是原子的，线程试图并行对队列执行push或者pop操作&lt;strong&gt;不会引起死锁&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;多个线程同时push元素进queue，不会&lt;strong&gt;写入到array同一个位置&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;多个线程同时pop元素出queue，不会&lt;strong&gt;多次获取到同一个位置元素&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;queue满了不能继续push元素，空了不能pop元素&lt;&#x2F;li&gt;
&lt;li&gt;push和pop操作都不会导致ABA问题&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;然而需要注意的是即使算法是线程安全的，它在多个生产者场景中变现也比基于simple block-based queue好。因此，仅在以下两种情况下选择block-based queue才有意义：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;只有一个生产者线程（版本2的 single-producer 更快）&lt;&#x2F;li&gt;
&lt;li&gt;有一个一直繁忙的生产者线程（译者注：一个长时间占用锁的生产者线程），然后我们仍然需要线程安全，因为还是可能会有其他生产者插入进去搞点事情&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;8-history&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#8-history&quot; aria-label=&quot;Anchor link for: 8-history&quot;&gt;8. History&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;4rd January 2011: Initial version&lt;&#x2F;p&gt;
&lt;p&gt;27th April 2011: Highlighting of some key words. Removed unnecesary uploaded file. A few typos fixed&lt;&#x2F;p&gt;
&lt;p&gt;31st July 2015: Updated code after &lt;a href=&quot;http:&#x2F;&#x2F;www.codeproject.com&#x2F;script&#x2F;Membership&#x2F;View.aspx?mid=8409915&quot;&gt;Artem Elkin&lt;&#x2F;a&gt; ([single producer](http:&#x2F;&#x2F;www.codeproject.com&#x2F;Messages&#x2F;4995350&#x2F;Single-producer-push.aspx and)) and &lt;a href=&quot;http:&#x2F;&#x2F;www.codeproject.com&#x2F;script&#x2F;Membership&#x2F;View.aspx?mid=11590800&quot;&gt;Member 11590800&lt;&#x2F;a&gt; &lt;a href=&quot;http:&#x2F;&#x2F;www.codeproject.com&#x2F;Messages&#x2F;5038886&#x2F;overflow-bug.aspx&quot;&gt;(overflow bug&lt;&#x2F;a&gt;) comments.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;9-references&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#9-references&quot; aria-label=&quot;Anchor link for: 9-references&quot;&gt;9. References&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;【译者注：请参考原文中的引用，有些引用连接已经失效，在正文翻译中已经尽可能还原了可用链接】&lt;&#x2F;p&gt;
</content>
    </entry>
</feed>
