<!doctype html><html lang=en-US><head><meta charset=utf-8><meta content="ie=edge" http-equiv=x-ua-compatible><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><link as=font crossorigin href=https://wendajiang.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 rel=preload type=font/woff2><link as=font crossorigin href=https://wendajiang.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2 rel=preload type=font/woff2><link href=https://wendajiang.github.io/main.css rel=stylesheet><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>【翻译】零拷贝的意义 | 「靡不有初，鲜克有终」</title><meta content="blog of david" name=description><link href=https://wendajiang.github.io/zero-copy/ rel=canonical><meta content=【翻译】零拷贝的意义 property=og:title><meta content="blog of david" property=og:description><meta content=article property=og:type><meta content=https://wendajiang.github.io/zero-copy/ property=og:url><meta content=https://wendajiang.github.io/david.png property=og:image><meta property=og:updated_time><meta content=【翻译】零拷贝的意义 property=og:site_name><meta content=en_US property=og:locale><script type=application/ld+json>
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/zero-copy/"
      },
      "headline": "【翻译】零拷贝的意义",
      "image": ,
      "datePublished": "2021-10-18T21:14:37",
      "dateModified": "",
      "author": {
        "@type": "Organization",
        "name": "【翻译】零拷贝的意义"
      },
      "publisher": {
        "@type": "Organization",
        "name": "【翻译】零拷贝的意义",
        
        "logo": {
          "@type": "ImageObject",
          "url": "/david.png"
        }
        
      },
      "description": "blog of david"
    }
    </script><script type=application/ld+json>
  {
    "@context": "http://schema.org",
    "@type": "BreadcrumbList",
    
      
      
        
        
        
        
        
        
        
        
        
        
        
          {
            "@type": "ListItem",
            "position":  1 ,
            "name": "Home",
            "item": "https://wendajiang.github.io/"
          },
          
          
          {
            "@type": "ListItem",
            "position":  2 ,
            "name": "Zero Copy",
            "item": "https://wendajiang.github.io/zero-copy/"
          },
        
      
    
  }
</script><meta content=#fff name=theme-color><link href=https://wendajiang.github.io/david.png rel=apple-touch-icon sizes=180x180><link href=https://wendajiang.github.io/david.png rel=icon sizes=32x32 type=image/png><link href=https://wendajiang.github.io/david.png rel=icon sizes=16x16 type=image/png><link crossorigin href=https://wendajiang.github.io/site.webmanifest rel=manifest><link href=https://wendajiang.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq rel=stylesheet><script crossorigin defer integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script crossorigin defer integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI onload=renderMathInElement(document.body); src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script>function initMermaid(){var a={startOnLoad:true,theme:"neutral",flowchart:{useMaxWidth:true,htmlLabels:true}};mermaid.initialize(a);window.mermaid.init(undefined,document.querySelectorAll('.mermaid'))}</script><script async onload=initMermaid() src=https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js></script><body class="blog single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" id=menu-btn type=checkbox><label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://wendajiang.github.io>「靡不有初，鲜克有终」</a><button aria-label="Toggle mode" class="btn btn-link order-2 order-md-4" id=mode type=button><span class=toggle-dark><svg class="feather feather-moon" viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></span> <span class=toggle-light><svg class="feather feather-sun" viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg></span></button><ul class="navbar-nav fork-me order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/wendajiang><svg class="feather feather-github" viewbox="0 0 24 24" fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 xmlns=http://www.w3.org/2000/svg><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg><span class="ms-2 visually-hidden">GitHub</span></a></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/books/effective-modern-cpp/>Books</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/turtle/>Turtle</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/essay/>Essay</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/QA/>Q&A</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/tags>Tags</a><li class=nav-item><a class=nav-link href=https://wendajiang.github.io/archive>Archive</a></ul><div class="break order-6 d-md-none"></div></div></div></header><div class="wrap container" role=document><div class=content><div class="row justify-content-center"><nav aria-label="Secondary navigation" class="books-toc d-none d-xl-block col-xl-3"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=https://wendajiang.github.io/zero-copy/#shi-yao-shi-ling-kao-bei>什么是零拷贝</a></li><ul><li><a href=https://wendajiang.github.io/zero-copy/#mmap>mmap</a><li><a href=https://wendajiang.github.io/zero-copy/#sendfile>Sendfile</a><li><a href=https://wendajiang.github.io/zero-copy/#sendfile-gather-hardware>sendfile + gather(hardware)</a><li><a href=https://wendajiang.github.io/zero-copy/#splice>splice</a></li><ul><li><a href=https://wendajiang.github.io/zero-copy/#xie-shi-fu-zhi>写时复制</a><li><a href=https://wendajiang.github.io/zero-copy/#huan-chong-qu-gong-xiang>缓冲区共享</a><li><a href=https://wendajiang.github.io/zero-copy/#linuxling-kao-bei-dui-bi>Linux零拷贝对比</a></ul></ul></ul></nav></div></nav><div class="col-md-12 col-lg-10 col-xxl-8"><article><div class=blog-header><h1>【翻译】零拷贝的意义</h1><p><small>Posted 2021-10-18 21:14:37 ‐ <strong>16 min read</strong></small><p><div class=category-area>「 <a href=https://wendajiang.github.io/tags/translate> <div class=category>translate</div> </a><a href=https://wendajiang.github.io/tags/linux> <div class=category>linux</div> </a><a href=https://wendajiang.github.io/tags/kernel> <div class=category>kernel</div> </a> 」</div></div><p><a href=https://www.linuxjournal.com/article/6345>原文</a><h2 id=shi-yao-shi-ling-kao-bei><a aria-label="Anchor link for: shi-yao-shi-ling-kao-bei" class=zola-anchor href=#shi-yao-shi-ling-kao-bei>什么是零拷贝</a></h2><p>为了更好地理解解决了什么问题，首先要理解问题本身。我们来看下下面的代码发生了什么<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=color:#50fa7b>read</span><span>(file, tmp_buf, len);
</span><span style=color:#50fa7b>write</span><span>(socket, tmp_buf, len);
</span></code></pre><p>看起来简单，你可能觉得两次系统调用也不是多大的开销。实际上，远比你想象中的大。这两次系统调用之下，<strong>数据拷贝了四次</strong>，并且还有内核态和用户态之间的上下文切换（实际上这个进程更复杂，但是先保持这种程度的简化）。为了更好地了解这个进程的调用，看下图<p><img alt=image-20211019174214718 src=https://wendajiang.github.io/pics/zero_copy/image-20211019174214718.png><p>第一步：read 系统调用发生了用户态到内核态的切换。第一次拷贝由DMA执行，从 disk 读取文件内容到内核空间的 buffer<p>第二步：数据从内核空间的 buffer 拷贝到用户空间的 buffer，然后 read 系统调用 return。return 又发生了内核态到用户态的切换。现在数据存储在用户态的 buffer 中<p>第三步：write 系统调用发生了用户态到内核态的切换。第三次拷贝从用户空间 buffer 到内核空间 buffer，这次内核空间的buffer 与 socket 关联<p>第四步：write 系统调用 return，触发了第四次上下文切换。单独异步的拷贝由DMA控制将数据从内核空间的 buffer 拷贝到协议栈中。你可能会问“什么叫独立异步？数据不是在return的时候就传输完成了吗？”事实上，return 并不保证传输完成；甚至不保证传输开始。可能在这次调用之前队列中有很多包，除非硬件驱动实现了优先队列，并且本次数据在第一优先级的队列中<p>正如你所看到的，很多数据拷贝实际本不必要发生。有些拷贝可以规避掉来减少开销提升程序性能。对一个驱动开发者，硬件实际有很多增强功能。有些硬件支持 bypass 主存，直接从将数据传输到其他设备。这个特性可以减少系统存储中的拷贝，但并不是所有硬件都支持。还有一个问题就是从disk得到数据需要为了网络重新封装，这带来了复杂性。为了减少开销，我们可以从减少内核空间和用户空间之间的拷贝开始。<h3 id=mmap><a aria-label="Anchor link for: mmap" class=zola-anchor href=#mmap>mmap</a></h3><p>一个方法就是避免使用read，而使用 mmap<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span>tmp_buf </span><span style=color:#ff79c6>= </span><span style=color:#50fa7b>mmap</span><span>(file, len);
</span><span style=color:#50fa7b>write</span><span>(socket, tmp_buf, len);
</span></code></pre><p>为了更好地理解这个过程，看下图<p><img alt=image-20211019192834679 src=https://wendajiang.github.io/pics/zero_copy/image-20211019192834679.png><p>第一步：mmap 系统调用使得文件内容通过 DMA 从disk 拷贝到内核空间的buffer，这个buffer可以直接在用户空间访问，不需要拷贝到用户空间<p>第二步：write 系统调用使得内核将内核空间buffer中的数据拷贝到 socket 关联的内核buffer中<p>第三步：第三次拷贝是 DMA 将socket buffer中的数据拷贝到协议栈中<p>通过使用 mmap，我们减少了一次使用 CPU 的拷贝。当大量数据传输时这比较有用，但并不是没有代价，有些隐藏的问题其实。当另一个进程也mmap到了同一个文件，然后对其进行了写入操作。上面代码的 write 就会被 SIGBUS 中断。这个信号默认的行为是杀死进程并coredump -- 这个操作对于网络服务器恨不能接受。有两种方法解决这个问题<p>第一个是定义一下 SIGBUS 的信号处理程序，直接return。这样 write 系统调用就会返回中断前写入的字节数，然后 errno 被设置为成功。这是个垃圾方案，无视问题，因为 SIGBUS 实际表示进程发生了严重错误，不应该无视<p>第二个是使用内核的文件租约（也叫“乐观锁”）。这是正确的解决方案。你可以从内核请求 read/write lease，当另一个进程视图对同一个文件进行截断时，内核会发送 RT_SINGAL_LEASE信号给有租约的进程，告诉你内核正在打断你的租约。你的写请求就会在程序访问无效地址之前被中断而不会导致 SIGBUS。write的返回值就是已经写入的字节数，errno被设置为成功，代码如下<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=color:#ff79c6>if </span><span>(</span><span style=color:#50fa7b>fcntl</span><span>(fd, F_SETSIG, RT_SIGNAL_LEASE) </span><span style=color:#ff79c6>== -</span><span style=color:#bd93f9>1</span><span>) </span><span style=color:#fff>{
</span><span>  </span><span style=color:#8be9fd>perror</span><span>(</span><span style=color:#f1fa8c>"kernel lease set signal"</span><span>);
</span><span>  </span><span style=color:#ff79c6>return -</span><span style=color:#bd93f9>1</span><span>;
</span><span style=color:#fff>}
</span><span style=color:#6272a4>/*l_type can be F_RDLCK F_WRLCK*/
</span><span style=color:#ff79c6>if </span><span>(</span><span style=color:#50fa7b>fcntl</span><span>(fd, F_SETLEASE, l_type)) </span><span style=color:#fff>{
</span><span>  </span><span style=color:#50fa7b>peror</span><span>(</span><span style=color:#f1fa8c>"kernel lease set type"</span><span>);
</span><span>  </span><span style=color:#ff79c6>return -</span><span style=color:#bd93f9>1</span><span>;
</span><span style=color:#fff>}
</span></code></pre><p>你应该在 mmap file之前获取租约，然后完成写入后主动放弃租约。通过调用 fcntl(F_SETLEASE, F_UNLCK)<h3 id=sendfile><a aria-label="Anchor link for: sendfile" class=zola-anchor href=#sendfile>Sendfile</a></h3><p>在内核2.1版本，sendfile 系统调用简化了将数据从文件传输到socket的方法，不仅减少了数据拷贝，还减少了内核与用户空间的上下文切换<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=color:#50fa7b>sendfile</span><span>(socket, file, len);
</span></code></pre><p>为了更好地理解底层过程，如下图<p><img alt=image-20211019194434427 src=https://wendajiang.github.io/pics/zero_copy/image-20211019194434427.png><p>第一步：sendfile 系统调用使得文件内容通过 DMA 拷贝到内核buffer，然后数据被内核拷贝到 socket buffer<p>第二步：第三次拷贝 DMA 控制从 socket buffer 拷贝到协议栈<p>你可能想知道如果另一个进程截断了这个文件，sendfile会发生什么。如果没有注册信号处理函数，sendfile 调用会返回已经传输的字节，errno被设置为成功<p>如果 sendfile 之前获取了文件租约，行为相同。同时sendfile return前会有 RT_SIGNAL_LEASE 信号<h3 id=sendfile-gather-hardware><a aria-label="Anchor link for: sendfile-gather-hardware" class=zola-anchor href=#sendfile-gather-hardware>sendfile + gather(hardware)</a></h3><p>如此说来，我们已经避免了内核进行多次拷贝，但是还有一次拷贝，可以也避免吗？当然，但是需要硬件的支持。为了消除内核的所有拷贝，需要网卡支持 gather 操作。内核2.4版本引入了socket对这种操作的支持，这种方法不需要内核态切换，也不需要处理器进行数据拷贝。同时用户代码不变<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=color:#50fa7b>sendfile</span><span>(socket, file, len);
</span></code></pre><p>底层流程如下图<p><img alt=image-20211019200216564 src=https://wendajiang.github.io/pics/zero_copy/image-20211019200216564.png><p>第一步：sendfile 系统调用可以将文件内容通过 DMA 拷贝到内核 buffer<p>第二步：没有数据被拷贝到 socket buffer。socket 文件描述符只有数据的长度信息。DMA 直接将数据从kernel buffer 拷贝到协议栈<p>因为数据从 disk 到主存的拷贝和从主存到总线的拷贝，有些人觉得这也不是零拷贝。这只是从操作系统角度的零拷贝，因为在操作系统中只有一个buffer。当使用零拷贝时，性能提升还来自，比如更少的内核用户态切换，更少的 CPU cache 污染以及不需要 CPU 校验<p>现在我们知道了什么是零拷贝，练习些代码吧。你可以下载<a href=https://wendajiang.github.io/zero-copy/%5Bwww.xalien.org/articles/source/sfl-src.tgz%5D(http://www.xalien.org/articles/source/sfl-src.tgz)>完整代码</a>。<p><a href="https://www.uidaho.edu/-/media/UIdaho-Responsive/Files/engr/research/csds/publications/2012/Performance-Review-of-Zero-Copy-Techniques-2012.pdf?la=en&hash=B5F37435875AAD15C55C7DFC1FDA53DBF242C0E3">论文</a><h3 id=splice><a aria-label="Anchor link for: splice" class=zola-anchor href=#splice>splice</a></h3><p>sendfile 只适用于将数据从文件拷贝到socket（依赖于具体实现，linux系统可以从文件到文件），而且使用 gather 需要硬件的支持。Linux 在2.6.17版本中实现了 splice 系统调用，不需要硬件支持，实现了两个文件描述符之间的数据零拷贝。<pre class=language-cpp data-lang=cpp style=background:#282a36;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=color:#50fa7b>Copysplice</span><span>(fd_in, off_in, fd_out, off_out, len, flags);
</span></code></pre><p>splice 系统调用在内核空间的 buffer 和 socket buffer 之间建立了管道，避免了两者之间的 CPU 拷贝操作<p><img alt=image-20211020191755511 src=https://wendajiang.github.io/pics/zero_copy/image-20211020191755511.png><p>基于 splice 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，0 次 CPU 拷贝以及 2 次 DMA 拷贝，用户程序读写数据的流程如下：<ol><li>用户进程通过 <code>splice()</code> 函数向内核(kernel)发起系统调用，上下文从用户态 (user space) 切换为内核态(kernel space)；<li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间 (kernel space) 的读缓冲区 (read buffer)；<li>CPU 在内核空间的读缓冲区 (read buffer) 和网络缓冲区(socket buffer)之间建立管道 (pipeline)；<li>CPU 利用 DMA 控制器将数据从网络缓冲区 (socket buffer) 拷贝到网卡进行数据传输；<li>上下文从内核态 (kernel space) 切换回用户态 (user space)，splice 系统调用执行返回。</ol><p>splice 拷贝方式也同样存在用户程序不能对数据进行修改的问题。除此之外，它使用了 Linux 的管道缓冲机制，可以用于任意两个文件描述符中传输数据，但是它的两个文件描述符参数中有一个必须是管道设备。<h5 id=xie-shi-fu-zhi><a aria-label="Anchor link for: xie-shi-fu-zhi" class=zola-anchor href=#xie-shi-fu-zhi>写时复制</a></h5><p>在某些情况下，内核缓冲区可能被多个进程所共享，如果某个进程想要这个共享区进行 write 操作，由于 write 不提供任何的锁操作，那么就会对共享区中的数据造成破坏，写时复制的引入就是 Linux 用来保护数据的。<p>写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么就需要将其拷贝到自己的进程地址空间中。这样做并不影响其他进程对这块数据的操作，每个进程要修改的时候才会进行拷贝，所以叫写时拷贝。这种方法在某种程度上能够降低系统开销，如果某个进程永远不会对所访问的数据进行更改，那么也就永远不需要拷贝。<p>缺点：<p>需要 MMU 的支持，MMU 需要知道进程地址空间中哪些页面是只读的，当需要往这些页面写数据时，发出一个异常给操作系统内核，内核会分配新的存储空间来供写入的需求。<h5 id=huan-chong-qu-gong-xiang><a aria-label="Anchor link for: huan-chong-qu-gong-xiang" class=zola-anchor href=#huan-chong-qu-gong-xiang>缓冲区共享</a></h5><p>缓冲区共享方式完全改写了传统的 I/O 操作，传统的 Linux I/O 接口支持数据在应用程序地址空间和操作系统内核之间交换，这种交换操作导致所有的数据都需要进行拷贝。<p>如果采用 fbufs 这种方法，需要交换的是包含数据的缓冲区，这样就消除了多余的拷贝操作。应用程序将 fbuf 传递给操作系统内核，这样就能减少传统的 write 系统调用所产生的数据拷贝开销。<p>同样的应用程序通过 fbuf 来接收数据，这样也可以减少传统 read 系统调用所产生的数据拷贝开销。<p>fbuf 的思想是每个进程都维护着一个缓冲区池，这个缓冲区池能被同时映射到用户空间 (user space) 和内核态 (kernel space)，内核和用户共享这个缓冲区池，这样就避免了一系列的拷贝操作。<p><img alt=12 src=https://wendajiang.github.io/pics/zero_copy/007S8ZIlgy1ggj9hmikddj30gy0c4mys.png><p>缺点：<p>缓冲区共享的难度在于管理共享缓冲区池需要应用程序、网络软件以及设备驱动程序之间的紧密合作，而且如何改写 API 目前还处于试验阶段并不成熟。<h4 id=linuxling-kao-bei-dui-bi><a aria-label="Anchor link for: linuxling-kao-bei-dui-bi" class=zola-anchor href=#linuxling-kao-bei-dui-bi>Linux零拷贝对比</a></h4><p>无论是传统 I/O 拷贝方式还是引入零拷贝的方式，2 次 DMA Copy 是都少不了的，因为两次 DMA 都是依赖硬件完成的。下面从 CPU 拷贝次数、DMA 拷贝次数以及系统调用几个方面总结一下上述几种 I/O 拷贝方式的差别。<table><thead><tr><th>拷贝方式<th style=text-align:center>CPU拷贝<th style=text-align:center>DMA拷贝<th style=text-align:center>系统调用<th style=text-align:center>上下文切换<tbody><tr><td>传统方式(read + write)<td style=text-align:center>2<td style=text-align:center>2<td style=text-align:center>read / write<td style=text-align:center>4<tr><td>内存映射(mmap + write)<td style=text-align:center>1<td style=text-align:center>2<td style=text-align:center>mmap / write<td style=text-align:center>4<tr><td>sendfile<td style=text-align:center>1<td style=text-align:center>2<td style=text-align:center>sendfile<td style=text-align:center>2<tr><td>sendfile + DMA gather copy<td style=text-align:center>0<td style=text-align:center>2<td style=text-align:center>sendfile<td style=text-align:center>2<tr><td>splice<td style=text-align:center>0<td style=text-align:center>2<td style=text-align:center>splice<td style=text-align:center>2</table></article></div></div></div><div id=gitalk-container></div><link href=https://unpkg.com/gitalk/dist/gitalk.css rel=stylesheet><script src=https://unpkg.com/gitalk/dist/gitalk.min.js></script><script>var gitalk=new Gitalk({id:'【翻译】零拷贝的意义',clientID:'a17500877ddbb2dd70b9',clientSecret:'77e1c5816e97e2473c0a617bd0e3ece99f33559f',repo:'wendajiang.github.io',owner:'wendajiang',admin:['wendajiang'],perPage:50});gitalk.render('gitalk-container')</script></div><script defer src=https://wendajiang.github.io/js/main.js></script><script defer src=https://wendajiang.github.io/plugins/elasticlunr.min.js></script><script defer src=https://wendajiang.github.io/search_index.en.js></script><script defer src=https://wendajiang.github.io/js/search.js></script>